<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screeny Session Viewer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        h1, h2, h3 {
            margin-bottom: 0.3em;
            color: #343a40;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .drop-area {
            border: 2px dashed #007bff;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background-color: #e9f6ff;
            margin-bottom: 20px;
            transition: background-color 0.2s;
            position: relative;
        }
        .drop-area.active {
            background-color: #cce5ff;
            border-color: #0056b3;
        }
        .drop-area.loading {
            background-color: #f0f0f0;
            pointer-events: none;
        }
        .drop-area p {
            margin: 10px 0;
            font-size: 16px;
            color: #6c757d;
        }
        .sessions-container {
            margin-top: 30px;
        }
        .drop-instructions {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        .session-view {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 30px;
        }
        .session-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .btn-close {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 20px;
            line-height: 30px;
            text-align: center;
            padding: 0;
            cursor: pointer;
        }
        .btn-close:hover {
            background-color: #c82333;
        }
        .display-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        .display-view {
            flex: 1;
            min-width: 400px; 
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            background-color: #f8f9fa;
        }
        video {
            width: 100%;
            border-radius: 4px;
            background-color: #000;
        }
        .log-container {
            margin-top: 15px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            background-color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 13px;
        }
        .log-entry {
            padding: 3px 5px;
            margin-bottom: 2px;
            border-radius: 3px;
        }
        .log-entry.keystroke {
            background-color: #e9f7ef;
        }
        .log-entry.mouse {
            background-color: #eaf2f8;
        }
        .log-entry.current {
            background-color: #fff3cd;
            font-weight: bold;
        }
        .log-timestamp {
            color: #6c757d;
            margin-right: 8px;
        }
        .log-tabs {
            display: flex;
            margin-bottom: 8px;
        }
        .log-tab {
            padding: 5px 10px;
            border: 1px solid #dee2e6;
            border-radius: 4px 4px 0 0;
            margin-right: 5px;
            cursor: pointer;
            background-color: #f8f9fa;
        }
        .log-tab.active {
            background-color: white;
            border-bottom-color: white;
            position: relative;
            z-index: 1;
        }
        .key-indicator {
            display: inline-block;
            padding: 2px 5px;
            background-color: #f1f3f5;
            border: 1px solid #ced4da;
            border-radius: 3px;
            margin: 0 2px;
        }
        .controls {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        select, button {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            background-color: white;
            font-size: 14px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0069d9;
        }
        .chunk-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        .chunk-list-item {
            padding: 8px 12px;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .chunk-list-item:last-child {
            border-bottom: none;
        }
        .chunk-list-item:hover {
            background-color: #f1f3f5;
        }
        .chunk-highlight {
            background-color: #fff3cd;
        }
        .message {
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .notice {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .no-displays {
            text-align: center;
            padding: 20px;
            color: #6c757d;
            font-style: italic;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #007bff;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .time-range-header {
            padding: 5px;
            background-color: #f1f3f5;
            border-radius: 4px;
            margin-bottom: 10px;
            font-weight: bold;
            color: #495057;
            text-align: center;
        }
        /* New styles for upload UI */
        .upload-controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #e9f7ef;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .upload-button {
            background-color: #28a745;
            color: white;
            font-size: 16px;
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .upload-button:hover {
            background-color: #218838;
        }
        .upload-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .selection-checkbox {
            margin-right: 10px;
            width: 16px;
            height: 16px;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .checkbox-label {
            margin-left: 5px;
            cursor: pointer;
        }
        .selection-summary {
            margin: 10px 0;
            font-size: 14px;
            color: #495057;
        }
        .session-title {
            display: flex;
            align-items: center;
        }
        .display-title {
            display: flex;
            align-items: center;
        }
        .chunk-list-item {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Screeny Session Viewer</h1>
        
        <div id="dropArea" class="drop-area">
            <p class="drop-instructions">Drag and drop a Screeny session folder here</p>
            <p>(Your session folder should be named something like "session_20250223_204746")</p>
            <p>or</p>
            <label for="folderInput" style="display: inline-block; margin: 10px; padding: 8px 16px; background-color: #007bff; color: white; border-radius: 4px; cursor: pointer;">
                Click to browse for folder
            </label>
            <input type="file" id="folderInput" webkitdirectory directory multiple style="opacity: 0; position: absolute;">
            <div id="loadingOverlay" class="loading-overlay" style="display: none;">
                <div class="spinner"></div>
                <p>Loading session data...</p>
            </div>
        </div>
        
        <div id="messageArea"></div>
        
        <div id="uploadControls" class="upload-controls" style="display: none;">
            <h2>Prepare Files for Upload</h2>
            <p class="selection-summary">Select which sessions, displays, and chunks you want to upload:</p>
            <div id="selectionSummary" class="selection-summary">
                <p>No items selected for upload.</p>
            </div>
            <button id="uploadButton" class="upload-button" disabled>Upload Selected Files</button>
        </div>
        
        <div id="sessionsContainer" class="sessions-container"></div>
    </div>

    <script>
        // Sessions data
        let sessions = [];
        
        // DOM Elements
        const dropArea = document.getElementById('dropArea');
        const folderInput = document.getElementById('folderInput');
        const messageArea = document.getElementById('messageArea');
        const sessionsContainer = document.getElementById('sessionsContainer');
        const loadingOverlay = document.getElementById('loadingOverlay');
        
        // Loading state management
        function showLoading() {
            loadingOverlay.style.display = 'flex';
            dropArea.classList.add('loading');
        }
        
        function hideLoading() {
            loadingOverlay.style.display = 'none';
            dropArea.classList.remove('loading');
        }
        
        // Improved event handling
        console.log('Setting up event listeners for drag and drop');
        
        // Add event listeners to prevent default browser behavior
        document.addEventListener('dragenter', preventDefaults, false);
        document.addEventListener('dragover', preventDefaults, false);
        document.addEventListener('dragleave', preventDefaults, false);
        document.addEventListener('drop', preventDefaults, false);
        
        // Also prevent defaults on drop area
        dropArea.addEventListener('dragenter', preventDefaults, false);
        dropArea.addEventListener('dragover', preventDefaults, false);
        dropArea.addEventListener('dragleave', preventDefaults, false);
        dropArea.addEventListener('drop', preventDefaults, false);
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('Prevented default behavior on', e.type);
        }
        
        // Add highlighting for visual feedback
        dropArea.addEventListener('dragenter', highlight, false);
        dropArea.addEventListener('dragover', highlight, false);
        dropArea.addEventListener('dragleave', unhighlight, false);
        dropArea.addEventListener('drop', unhighlight, false);
        
        function highlight() {
            dropArea.classList.add('active');
        }
        
        function unhighlight() {
            dropArea.classList.remove('active');
        }
        
        // Handle dropped files
        dropArea.addEventListener('drop', handleDrop, false);
        console.log('Added drop handler to drop area');
        
        // Handle files selected via input
        folderInput.addEventListener('change', handleFileSelect, false);
        console.log('Added change handler to folder input');
        
        // Add a message on page load to confirm script execution
        console.log('Page fully loaded, handlers attached');
        
        function handleDrop(e) {
            console.log('ðŸ”´ Drop event triggered!', e);
            e.preventDefault(); // Prevent browser from opening the file
            e.stopPropagation();
            
            // Show loading overlay
            showLoading();
            
            try {
                const dt = e.dataTransfer;
                console.log('DataTransfer object:', dt);
                
                if (!dt) {
                    console.error('No dataTransfer in drop event');
                    hideLoading();
                    showMessage('Error: Unable to access dropped data', 'error');
                    return;
                }
                
                const files = dt.files;
                console.log('Handling dropped files', files ? files.length : 'no files property');
                
                // For drag and drop, we need to handle directory entries differently
                if (dt.items && dt.items.length > 0) {
                    // Use DataTransferItemList interface to access the files
                    const items = Array.from(dt.items);
                    console.log('Found items in drop', items.length);
                    
                    // Process each dropped item (could be multiple folders)
                    let foundDirectories = false;
                    
                    // Add a counter to track when all sessions are processed
                    let sessionsToProcess = 0;
                    let sessionsProcessed = 0;
                    
                    // Function to check if all sessions are processed
                    function checkAllSessionsProcessed() {
                        sessionsProcessed++;
                        console.log(`Processed ${sessionsProcessed} of ${sessionsToProcess} sessions`);
                        
                        if (sessionsProcessed === sessionsToProcess) {
                            // All sessions are processed, now hide loading and render
                            console.log('All sessions processed, hide loading and render');
                            hideLoading();
                            renderAllSessions();
                        }
                    }
                    
                    // First, count how many sessions we need to process
                    for (const item of items) {
                        const getEntryMethod = item.webkitGetAsEntry || item.getAsEntry;
                        if (item.kind === 'file' && getEntryMethod) {
                            const entry = getEntryMethod.call(item);
                            if (entry && entry.isDirectory && entry.name.startsWith('session_')) {
                                sessionsToProcess++;
                                foundDirectories = true;
                            }
                        }
                    }
                    
                    console.log(`Found ${sessionsToProcess} session directories to process`);
                    
                    // If no sessions to process, hide loading immediately
                    if (sessionsToProcess === 0) {
                        hideLoading();
                        if (!foundDirectories) {
                            showMessage('No valid Screeny session folders found', 'error');
                        }
                        return;
                    }
                    
                    // Now process each session
                    for (const item of items) {
                        console.log('Processing item:', item.kind, item.type, item);
                        
                        // Try both webkitGetAsEntry and getAsEntry (for Firefox support)
                        const getEntryMethod = item.webkitGetAsEntry || item.getAsEntry;
                        
                        if (item.kind === 'file' && getEntryMethod) {
                            const entry = getEntryMethod.call(item);
                            console.log('Got entry:', entry);
                            
                            if (entry && entry.isDirectory) {
                                foundDirectories = true;
                                console.log('Processing directory entry:', entry.name);
                                
                                // Only process session directories
                                if (entry.name.startsWith('session_')) {
                                    // Modified to use our session completion callback
                                    processDirectoryEntry(entry, checkAllSessionsProcessed);
                                } else {
                                    // Not a session directory, don't count it
                                    console.log(`Skipping non-session directory: ${entry.name}`);
                                }
                            } else if (entry && entry.isFile) {
                                console.log('Skipping individual file entry:', entry.name);
                            }
                        }
                    }
                    
                    if (foundDirectories) {
                        console.log('Processed directories, skipping file handling');
                        return;
                    } else {
                        console.log('No directory entries found among items');
                    }
                } else {
                    console.log('No items in dataTransfer, or items not supported');
                }
                
                // Fallback to regular file handling if no directories were found
                if (files && files.length > 0) {
                    handleFiles(files);
                } else {
                    console.error('No files in drop event');
                    hideLoading();
                    showMessage('No files found in drop. Please try selecting via the file input instead.', 'error');
                }
            } catch (error) {
                console.error('Error in drop handler:', error);
                hideLoading();
                showMessage('Error processing drop: ' + error.message, 'error');
            }
        }
        
        function processDirectoryEntry(entry, sessionCompletedCallback) {
            // Get the directory name (should be the session name)
            const sessionName = entry.name;
            
            console.log(`Processing directory entry: ${sessionName}`);
            
            if (!sessionName.startsWith('session_')) {
                showMessage('This doesn\'t look like a Screeny session folder (should start with "session_")', 'error');
                return;
            }
            
            // Check if this session is already loaded
            const existingSessionIndex = sessions.findIndex(s => s.name === sessionName);
            
            // Create the session data structure or update existing
            const sessionData = existingSessionIndex >= 0 
                ? sessions[existingSessionIndex] 
                : { 
                    name: sessionName, 
                    displays: {}, 
                    id: Date.now() + '-' + Math.random().toString(36).substring(2, 9),
                    logs: {
                        keystroke: [],
                        mouse: []
                    }
                  };
                  
            if (existingSessionIndex < 0) {
                sessions.push(sessionData);
            } else if (!sessionData.logs) {
                // Add logs field if it doesn't exist yet
                sessionData.logs = {
                    keystroke: [],
                    mouse: []
                };
            }
            
            // Keep track of all file and directory entries for batch processing
            // This helps with browser read limits and performance
            let allDisplayEntries = [];
            let keystrokeLogEntry = null;
            let mouseLogEntry = null;
            let displayInfoEntry = null;
            let readComplete = false;
            
            const reader = entry.createReader();
            
            // Read all entries in the directory
            function readEntries() {
                reader.readEntries(function(entries) {
                    if (entries.length === 0) {
                        readComplete = true;
                        processAllEntries();
                        return;
                    }
                    
                    // Collect display directory entries and session-level log files
                    for (const entryItem of entries) {
                        if (entryItem.isDirectory && entryItem.name.startsWith('display_')) {
                            console.log(`Found display directory: ${entryItem.name}`);
                            allDisplayEntries.push(entryItem);
                        } else if (entryItem.isFile) {
                            if (entryItem.name === 'keypresses.log') {
                                console.log(`Found keystroke log file at session level`);
                                keystrokeLogEntry = entryItem;
                            } else if (entryItem.name === 'mouse.log') {
                                console.log(`Found mouse log file at session level`);
                                mouseLogEntry = entryItem;
                            } else if (entryItem.name === 'display_info.json') {
                                console.log(`Found display info file`);
                                displayInfoEntry = entryItem;
                            }
                        }
                    }
                    
                    // Continue reading more entries
                    readEntries();
                }, function(error) {
                    readComplete = true;
                    showMessage(`Error reading directory: ${error.message}`, 'error');
                    processAllEntries();
                });
            }
            
            function processAllEntries() {
                if (!readComplete) return;
                
                console.log(`Processing ${allDisplayEntries.length} display directories`);
                
                if (allDisplayEntries.length === 0) {
                    hideLoading();
                    showMessage(`No display folders found in session: ${sessionName}`, 'error');
                    // Remove the session if no valid displays were found
                    const idx = sessions.findIndex(s => s.id === sessionData.id);
                    if (idx >= 0) {
                        sessions.splice(idx, 1);
                    }
                    
                    // Call the session completion callback if provided
                    if (sessionCompletedCallback) {
                        sessionCompletedCallback();
                    }
                    
                    return;
                }
                
                // Track loading of session-level files
                let sessionFilesLoaded = 0;
                const totalSessionFiles = (keystrokeLogEntry ? 1 : 0) + 
                                         (mouseLogEntry ? 1 : 0) + 
                                         (displayInfoEntry ? 1 : 0);
                
                // Function to check if all session-level files are loaded
                function checkSessionFilesLoaded() {
                    sessionFilesLoaded++;
                    if (sessionFilesLoaded === totalSessionFiles) {
                        // Process display directories after session files are loaded
                        processDisplayDirectories();
                    } else if (totalSessionFiles === 0) {
                        // No session files to load, go straight to displays
                        processDisplayDirectories();
                    }
                }
                
                // Load display info if available
                if (displayInfoEntry) {
                    displayInfoEntry.file(function(file) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                const displayInfo = JSON.parse(e.target.result);
                                console.log('Loaded display info:', displayInfo);
                                // Store display info if needed
                                sessionData.displayInfo = displayInfo;
                            } catch (error) {
                                console.error('Error parsing display info:', error);
                            }
                            checkSessionFilesLoaded();
                        };
                        reader.onerror = function() {
                            console.error('Error reading display info file');
                            checkSessionFilesLoaded();
                        };
                        reader.readAsText(file);
                    }, function(error) {
                        console.error('Error getting display info file:', error);
                        checkSessionFilesLoaded();
                    });
                }
                
                // Load keystroke log if available
                if (keystrokeLogEntry) {
                    keystrokeLogEntry.file(function(file) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                // Parse the log file (assuming it's one entry per line)
                                const logLines = e.target.result.split('\n').filter(line => line.trim());
                                
                                // Process each line as a log entry
                                const logEntries = logLines.map(line => {
                                    try {
                                        // Parse the custom tuple-like format
                                        // Match pattern like: (1740417881748, 'none')
                                        const match = line.match(/\((\d+),\s*'([^']+)'\)/);
                                        if (match) {
                                            const timestamp = parseInt(match[1], 10);
                                            const keyState = match[2];
                                            
                                            // Create an object with the extracted data
                                            const entry = {
                                                timestamp: timestamp,
                                                state: keyState
                                            };
                                            
                                            // Parse keys from state (e.g. '+MetaLeft+KeyQ' -> ['MetaLeft', 'KeyQ'])
                                            if (keyState !== 'none') {
                                                const keys = keyState.split('+').filter(k => k);
                                                entry.keys = keys;
                                                
                                                // Extract modifiers
                                                const modifiers = [];
                                                if (keys.some(k => k.includes('Shift'))) modifiers.push('shift');
                                                if (keys.some(k => k.includes('Control') || k.includes('Ctrl'))) modifiers.push('ctrl');
                                                if (keys.some(k => k.includes('Alt'))) modifiers.push('alt');
                                                if (keys.some(k => k.includes('Meta') || k.includes('Command'))) modifiers.push('meta');
                                                
                                                if (modifiers.length > 0) {
                                                    entry.modifiers = modifiers;
                                                }
                                                
                                                // Extract key code
                                                const mainKey = keys[keys.length - 1];
                                                entry.key = mainKey;
                                            }
                                            
                                            return entry;
                                        }
                                        return null;
                                    } catch (e) {
                                        console.error('Error parsing keystroke log line:', line, e);
                                        return null;
                                    }
                                }).filter(entry => entry !== null);
                                
                                sessionData.logs.keystroke = logEntries;
                                console.log(`Loaded ${logEntries.length} keystroke entries`);
                            } catch (error) {
                                console.error('Error processing keystroke log:', error);
                            }
                            checkSessionFilesLoaded();
                        };
                        reader.onerror = function() {
                            console.error('Error reading keystroke log file');
                            checkSessionFilesLoaded();
                        };
                        reader.readAsText(file);
                    }, function(error) {
                        console.error('Error getting keystroke log file:', error);
                        checkSessionFilesLoaded();
                    });
                }
                
                // Load mouse log if available
                if (mouseLogEntry) {
                    mouseLogEntry.file(function(file) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                // Parse the log file (assuming it's one entry per line)
                                const logLines = e.target.result.split('\n').filter(line => line.trim());
                                
                                // Process each line as a log entry
                                const logEntries = logLines.map(line => {
                                    try {
                                        // Parse the custom tuple-like format
                                        // Match pattern like: (1740417882986, {'type': 'move', 'x': 436.96484375, 'y': 903.2890625})
                                        const match = line.match(/\((\d+),\s*(\{[^}]+\})\)/);
                                        if (match) {
                                            const timestamp = parseInt(match[1], 10);
                                            const jsonStr = match[2].replace(/'/g, '"'); // Replace single quotes with double quotes
                                            
                                            try {
                                                // Parse the JSON object part
                                                const eventData = JSON.parse(jsonStr);
                                                
                                                // Create entry with timestamp and all event data
                                                return {
                                                    timestamp: timestamp,
                                                    ...eventData
                                                };
                                            } catch (jsonError) {
                                                console.error('Error parsing mouse event JSON:', jsonStr, jsonError);
                                                // Fallback parsing for cases where JSON parsing fails
                                                const typeMatch = jsonStr.match(/type':\s*'([^']+)'/);
                                                const xMatch = jsonStr.match(/x':\s*([\d\.\-]+)/);
                                                const yMatch = jsonStr.match(/y':\s*([\d\.\-]+)/);
                                                const deltaXMatch = jsonStr.match(/deltaX':\s*([\d\.\-]+)/);
                                                const deltaYMatch = jsonStr.match(/deltaY':\s*([\d\.\-]+)/);
                                                const buttonMatch = jsonStr.match(/button':\s*'([^']+)'/);
                                                const actionMatch = jsonStr.match(/action':\s*'([^']+)'/);
                                                
                                                const entry = { timestamp: timestamp };
                                                
                                                if (typeMatch) entry.type = typeMatch[1];
                                                if (xMatch) entry.x = parseFloat(xMatch[1]);
                                                if (yMatch) entry.y = parseFloat(yMatch[1]);
                                                if (deltaXMatch) entry.deltaX = parseFloat(deltaXMatch[1]);
                                                if (deltaYMatch) entry.deltaY = parseFloat(deltaYMatch[1]);
                                                if (buttonMatch) entry.button = buttonMatch[1];
                                                if (actionMatch) entry.action = actionMatch[1];
                                                
                                                return entry;
                                            }
                                        }
                                        return null;
                                    } catch (e) {
                                        console.error('Error parsing mouse log line:', line, e);
                                        return null;
                                    }
                                }).filter(entry => entry !== null);
                                
                                sessionData.logs.mouse = logEntries;
                                console.log(`Loaded ${logEntries.length} mouse entries`);
                            } catch (error) {
                                console.error('Error processing mouse log:', error);
                            }
                            checkSessionFilesLoaded();
                        };
                        reader.onerror = function() {
                            console.error('Error reading mouse log file');
                            checkSessionFilesLoaded();
                        };
                        reader.readAsText(file);
                    }, function(error) {
                        console.error('Error getting mouse log file:', error);
                        checkSessionFilesLoaded();
                    });
                }
                
                // If no session files to load, start processing display directories
                if (totalSessionFiles === 0) {
                    processDisplayDirectories();
                }
                
                function processDisplayDirectories() {
                    // Process each display directory
                    let displayProcessingCount = 0;
                    
                    // Create a function to be called when each display is processed
                    function displayProcessedCallback() {
                        displayProcessingCount++;
                        console.log(`Display ${displayProcessingCount} of ${allDisplayEntries.length} processed`);
                        
                        if (displayProcessingCount === allDisplayEntries.length) {
                            // All displays processed
                            console.log(`All displays processed for session ${sessionName}`);
                            
                            // Call the session completion callback if provided
                            if (sessionCompletedCallback) {
                                sessionCompletedCallback();
                            } else {
                                // If no callback provided (legacy code path), hide loading and render
                                hideLoading();
                                renderAllSessions();
                            }
                        }
                    }
                    
                    for (const displayEntry of allDisplayEntries) {
                        const displayName = displayEntry.name;
                        // Use a safe key without spaces
                        const displayKey = displayName.replace(/ /g, '_');
                        const reader = displayEntry.createReader();
                        
                        // Initialize the display's data structure if needed
                        if (!sessionData.displays[displayKey]) {
                            sessionData.displays[displayKey] = {
                                name: displayName,
                                chunks: []
                            };
                        }
                        
                        // Collect all chunk entries before processing them
                        const chunkEntries = [];
                        let readingComplete = false;
                        
                        function readDisplayEntries() {
                            reader.readEntries(function(entries) {
                                if (entries.length === 0) {
                                    readingComplete = true;
                                    processAllEntries();
                                    return;
                                }
                                
                                // Look for chunk MP4 files
                                for (const entry of entries) {
                                    if (entry.isFile && entry.name.startsWith('chunk_') && entry.name.endsWith('.mp4')) {
                                        chunkEntries.push(entry);
                                    }
                                }
                                
                                // Continue reading more entries
                                readDisplayEntries();
                            }, function(error) {
                                readingComplete = true;
                                console.error(`Error reading display directory: ${error.message}`);
                                processAllEntries();
                            });
                        }
                        
                        function processAllEntries() {
                            if (!readingComplete) return;
                            
                            console.log(`Processing ${chunkEntries.length} chunk files for display ${displayName}`);
                            
                            // First, look for frames.log file
                            let framesLogEntry = null;
                            
                            // Function to find and process frames.log
                            function findAndProcessFramesLog() {
                                reader.readEntries(function(entries) {
                                    for (const entry of entries) {
                                        if (entry.isFile && entry.name === 'frames.log') {
                                            console.log(`Found frames.log for display ${displayName}`);
                                            framesLogEntry = entry;
                                            break;
                                        }
                                    }
                                    
                                    // Process the frames.log file if found
                                    if (framesLogEntry) {
                                        framesLogEntry.file(function(file) {
                                            const reader = new FileReader();
                                            reader.onload = function(e) {
                                                try {
                                                    // Parse the frames log - one timestamp per line
                                                    const logLines = e.target.result.split('\n').filter(line => line.trim());
                                                    
                                                    // Convert to timestamp array
                                                    const frameTimestamps = logLines.map(line => parseInt(line.trim(), 10));
                                                    
                                                    // Store in display data
                                                    sessionData.displays[displayKey].frameTimestamps = frameTimestamps;
                                                    console.log(`Loaded ${frameTimestamps.length} frame timestamps for ${displayName}`);
                                                } catch (error) {
                                                    console.error(`Error processing frames.log for ${displayName}:`, error);
                                                }
                                                
                                                // After processing frames.log, handle chunks
                                                handleChunks();
                                            };
                                            reader.onerror = function() {
                                                console.error(`Error reading frames.log for ${displayName}`);
                                                handleChunks();
                                            };
                                            reader.readAsText(file);
                                        }, function(error) {
                                            console.error(`Error accessing frames.log: ${error}`);
                                            handleChunks();
                                        });
                                    } else {
                                        // No frames.log, just handle chunks
                                        handleChunks();
                                    }
                                });
                            }
                            
                            // Function to check and process chunks
                            function handleChunks() {
                                // Filter out the latest chunk to avoid issues with active recording
                                if (chunkEntries.length > 0) {
                                    // Sort to identify the latest chunk based on names like chunk_00001.mp4
                                    chunkEntries.sort((a, b) => {
                                        const fileNameA = a.name || (a.webkitRelativePath ? a.webkitRelativePath.split('/').pop() : '');
                                        const fileNameB = b.name || (b.webkitRelativePath ? b.webkitRelativePath.split('/').pop() : '');
                                        return fileNameA.localeCompare(fileNameB);
                                    });
                                    
                                    // For FileEntry objects, we need to convert to File objects to check sizes
                                    // We'll try accessing the last chunk to see if it's being recorded
                                    const lastChunkEntry = chunkEntries[chunkEntries.length - 1];
                                    const lastChunkName = lastChunkEntry.name || '';
                                    
                                    lastChunkEntry.file(function(file) {
                                        // Now we have the actual File object, check if it's smaller than expected
                                        
                                        // Get the sizes of all other chunks for comparison
                                        let previousChunksLoaded = 0;
                                        let totalPreviousSize = 0;
                                        
                                        function checkIfComplete() {
                                            previousChunksLoaded++;
                                            if (previousChunksLoaded === chunkEntries.length - 1) {
                                                // All previous chunks loaded, now we can compare
                                                const avgSize = totalPreviousSize / Math.max(1, chunkEntries.length - 1);
                                                
                                                // If the last chunk size is significantly less than average or zero, it's likely still recording
                                                if (file.size === 0 || (avgSize > 0 && file.size < avgSize * 0.5)) {
                                                    // Remove the last chunk
                                                    chunkEntries.pop();
                                                    console.log(`Latest chunk ${lastChunkName} appears to be recording (size: ${file.size}, avg: ${avgSize}), filtering it out`);
                                                } else {
                                                    console.log(`Latest chunk ${lastChunkName} seems complete (size: ${file.size}, avg: ${avgSize}), including it`);
                                                }
                                                
                                                // Continue with normal processing
                                                processChunks();
                                            }
                                        }
                                        
                                        // If we only have one chunk, just use it
                                        if (chunkEntries.length === 1) {
                                            console.log(`Only one chunk ${lastChunkName}, including it`);
                                            processChunks();
                                            return;
                                        }
                                        
                                        // Get file sizes for all previous chunks
                                        for (let i = 0; i < chunkEntries.length - 1; i++) {
                                            chunkEntries[i].file(function(prevFile) {
                                                totalPreviousSize += prevFile.size;
                                                checkIfComplete();
                                            }, function(error) {
                                                console.error(`Error getting size of chunk ${i}: ${error}`);
                                                checkIfComplete();
                                            });
                                        }
                                        
                                    }, function(error) {
                                        // If we can't access the file, it's definitely being recorded
                                        console.log(`Cannot access latest chunk ${lastChunkName}, likely being recorded: ${error}`);
                                        chunkEntries.pop();
                                        processChunks();
                                    });
                                } else {
                                    // No chunks to process
                                    processChunks();
                                }
                            }
                            
                            // Start by finding frames.log, which will then handle chunks
                            findAndProcessFramesLog();
                        }
                        
                        function processChunks() {
                            // Track progress for all file types
                            let totalFilesToProcess = chunkEntries.length;
                            let filesProcessed = 0;
                            
                            // Function to check if processing is complete
                            function checkProcessingComplete() {
                                filesProcessed++;
                                if (filesProcessed === totalFilesToProcess) {
                                    // Sort chunks by name
                                    sessionData.displays[displayKey].chunks.sort((a, b) => {
                                        return a.name.localeCompare(b.name);
                                    });
                                    
                                    // Check if we should update the view
                                    const sessionElement = document.querySelector(`[data-session-id="${sessionData.id}"]`);
                                    if (sessionElement) {
                                        // Update existing session
                                        updateChunkLists(sessionData);
                                        updateLogDisplays(sessionData);
                                    }
                                    
                                    // Call the display processed callback
                                    displayProcessedCallback();
                                }
                            }
                            
                            if (chunkEntries.length === 0) {
                                // No chunk files, just call the callback to continue
                                displayProcessedCallback();
                                return;
                            }
                            
                            // Process each chunk file
                            chunkEntries.forEach(entry => {
                                // Get the existing names to avoid duplicates
                                const existingNames = sessionData.displays[displayKey].chunks.map(c => c.name);
                                
                                if (existingNames.includes(entry.name)) {
                                    // Skip duplicate, but count as processed
                                    checkProcessingComplete();
                                } else {
                                    // Get the file object
                                    entry.file(function(file) {
                                        // Store the file in the display's chunks array
                                        sessionData.displays[displayKey].chunks.push(file);
                                        
                                        // Log for debugging
                                        console.log(`Added chunk ${file.name} to display ${displayName}`);
                                        
                                        // Check if we're done processing
                                        checkProcessingComplete();
                                    }, function(error) {
                                        console.error(`Error getting file: ${error.message}`);
                                        checkProcessingComplete();
                                    });
                                }
                            });
                        }
                        
                        // Start reading the display directory
                        console.log(`Starting to process display directory: ${displayName}`);
                        readDisplayEntries();
                    }
                }
            }
            
            // Start reading the session directory
            readEntries();
        }
        
        function handleFileSelect(e) {
            console.log('ðŸ”µ File input change event triggered!', e);
            
            try {
                // Show loading overlay
                showLoading();
                
                // Check if we have files
                const files = e.target.files;
                
                if (!files || files.length === 0) {
                    console.error('No files in file input change event');
                    hideLoading();
                    showMessage('No files selected', 'error');
                    return;
                }
                
                console.log('Selected files:', files.length);
                
                // Log some file information to help with debugging
                Array.from(files).slice(0, 5).forEach((file, i) => {
                    console.log(`File ${i}:`, {
                        name: file.name,
                        path: file.webkitRelativePath || 'No path',
                        size: file.size,
                        type: file.type
                    });
                });
                
                // Process files
                handleFiles(files);
            } catch (error) {
                console.error('Error in file select handler:', error);
                hideLoading();
                showMessage('Error processing files: ' + error.message, 'error');
            }
        }
        
        function handleFiles(fileList) {
            // Convert FileList to Array for easier processing
            const files = Array.from(fileList);
            
            // Process session structure
            processSessionFiles(files);
        }
        
        function processSessionFiles(files) {
            // Get unique session folders from the files
            const sessionFolders = new Map(); // Map of session name -> files
            
            // Group files by session folder
            files.forEach(file => {
                const path = file.webkitRelativePath || file.name;
                const parts = path.split('/');
                
                if (parts.length >= 2 && parts[0].startsWith('session_')) {
                    // This is a valid session path
                    const sessionName = parts[0];
                    
                    if (!sessionFolders.has(sessionName)) {
                        sessionFolders.set(sessionName, []);
                    }
                    
                    sessionFolders.get(sessionName).push(file);
                }
            });
            
            if (sessionFolders.size === 0) {
                hideLoading();
                showMessage('No valid Screeny session folders found', 'error');
                return;
            }
            
            // Process each session folder
            for (const [sessionName, sessionFiles] of sessionFolders.entries()) {
                // Check if this session already exists
                const existingSessionIndex = sessions.findIndex(s => s.name === sessionName);
                
                // Create new session data or use existing
                const sessionData = existingSessionIndex >= 0 
                    ? sessions[existingSessionIndex] 
                    : { 
                        name: sessionName, 
                        displays: {},
                        id: Date.now() + '-' + Math.random().toString(36).substring(2, 9),
                        logs: {
                            keystroke: [],
                            mouse: []
                        }
                      };
                
                if (existingSessionIndex < 0) {
                    sessions.push(sessionData);
                } else if (!sessionData.logs) {
                    // Add logs field if it doesn't exist yet
                    sessionData.logs = {
                        keystroke: [],
                        mouse: []
                    };
                }
                
                // Find all display folders for this session
                const displayFolders = new Set();
                
                sessionFiles.forEach(file => {
                    const path = file.webkitRelativePath || file.name;
                    const parts = path.split('/');
                    
                    // Debug logging
                    console.log(`Processing file path: ${path}`);
                    
                    if (parts.length >= 3 && parts[1].startsWith('display_')) {
                        displayFolders.add(parts[1]);
                        console.log(`Found display folder: ${parts[1]}`);
                    }
                });
                
                if (displayFolders.size === 0) {
                    showMessage(`No display folders found in session: ${sessionName}`, 'error');
                    // Remove the session if no displays were found
                    const idx = sessions.findIndex(s => s.id === sessionData.id);
                    if (idx >= 0) {
                        sessions.splice(idx, 1);
                    }
                    continue;
                }
                
                // Find session-level log files
                const keypressesLogFile = sessionFiles.find(file => {
                    const path = file.webkitRelativePath || file.name;
                    const parts = path.split('/');
                    return parts.length === 2 && parts[0] === sessionName && parts[1] === 'keypresses.log';
                });
                
                const mouseLogFile = sessionFiles.find(file => {
                    const path = file.webkitRelativePath || file.name;
                    const parts = path.split('/');
                    return parts.length === 2 && parts[0] === sessionName && parts[1] === 'mouse.log';
                });
                
                const displayInfoFile = sessionFiles.find(file => {
                    const path = file.webkitRelativePath || file.name;
                    const parts = path.split('/');
                    return parts.length === 2 && parts[0] === sessionName && parts[1] === 'display_info.json';
                });
                
                // Find all frames.log files for displays
                displayFolders.forEach(displayFolder => {
                    // Use a safe key without spaces
                    const displayKey = displayFolder.replace(/ /g, '_');
                    
                    // Create the display entry if it doesn't exist
                    if (!sessionData.displays[displayKey]) {
                        sessionData.displays[displayKey] = {
                            name: displayFolder,
                            chunks: []
                        };
                    }
                    
                    // Look for frames.log
                    const framesLogFile = sessionFiles.find(file => {
                        const path = file.webkitRelativePath || file.name;
                        const parts = path.split('/');
                        return parts.length >= 3 && 
                               parts[1] === displayFolder && 
                               parts[2] === 'frames.log';
                    });
                    
                    if (framesLogFile) {
                        console.log(`Found frames.log for ${displayFolder}`);
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                // Parse the frames log - one timestamp per line
                                const logLines = e.target.result.split('\n').filter(line => line.trim());
                                
                                // Convert to timestamp array
                                const frameTimestamps = logLines.map(line => parseInt(line.trim(), 10));
                                
                                // Store in display data
                                sessionData.displays[displayKey].frameTimestamps = frameTimestamps;
                                console.log(`Loaded ${frameTimestamps.length} frame timestamps for ${displayFolder}`);
                            } catch (error) {
                                console.error(`Error processing frames.log for ${displayFolder}:`, error);
                            }
                        };
                        reader.onerror = function() {
                            console.error(`Error reading frames.log for ${displayFolder}`);
                        };
                        reader.readAsText(framesLogFile);
                    }
                    
                    // Find all chunk files for this display
                    const chunkFiles = sessionFiles.filter(file => {
                        const path = file.webkitRelativePath || file.name;
                        const parts = path.split('/');
                        return parts.length >= 3 && 
                               parts[1] === displayFolder && 
                               parts[2].startsWith('chunk_') && 
                               parts[2].endsWith('.mp4');
                    });
                    
                    // Get existing chunk names to avoid duplicates
                    const existingChunkNames = sessionData.displays[displayKey].chunks.map(c => {
                        return c.name || c.webkitRelativePath?.split('/').pop() || '';
                    });
                    
                    // Filter out the latest chunk to avoid issues with active recording
                    if (chunkFiles.length > 0) {
                        // Sort to identify the latest chunk based on names like chunk_00001.mp4
                        chunkFiles.sort((a, b) => {
                            const fileNameA = a.name || (a.webkitRelativePath ? a.webkitRelativePath.split('/').pop() : '');
                            const fileNameB = b.name || (b.webkitRelativePath ? b.webkitRelativePath.split('/').pop() : '');
                            return fileNameA.localeCompare(fileNameB);
                        });
                        
                        // For regular File objects, we use size as an indicator
                        // The last chunk that's being recorded will typically have a smaller size 
                        // than previous chunks or might have a zero size
                        const lastChunk = chunkFiles[chunkFiles.length - 1];
                        const lastChunkName = lastChunk.name || (lastChunk.webkitRelativePath ? lastChunk.webkitRelativePath.split('/').pop() : '');
                        
                        // Get average size of other chunks
                        let avgSize = 0;
                        if (chunkFiles.length > 1) {
                            const totalSize = chunkFiles.slice(0, -1).reduce((sum, chunk) => sum + chunk.size, 0);
                            avgSize = totalSize / (chunkFiles.length - 1);
                        }
                        
                        // If the last chunk size is significantly less than average or zero, it's likely still recording
                        if (lastChunk.size === 0 || (avgSize > 0 && lastChunk.size < avgSize * 0.5)) {
                            chunkFiles.pop();
                            console.log(`Latest chunk ${lastChunkName} appears to be recording (size: ${lastChunk.size}, avg: ${avgSize}), filtering it out`);
                        } else {
                            console.log(`Latest chunk ${lastChunkName} seems complete (size: ${lastChunk.size}, avg: ${avgSize}), including it`);
                        }
                    }
                    
                    // Add new chunk files (avoid duplicates)
                    chunkFiles.forEach(chunkFile => {
                        const fileName = chunkFile.name || chunkFile.webkitRelativePath?.split('/').pop() || '';
                        
                        if (!existingChunkNames.includes(fileName)) {
                            sessionData.displays[displayKey].chunks.push(chunkFile);
                        }
                    });
                    
                    // Sort chunk files by name
                    sessionData.displays[displayKey].chunks.sort((a, b) => {
                        const fileNameA = a.name || (a.webkitRelativePath ? a.webkitRelativePath.split('/').pop() : '');
                        const fileNameB = b.name || (b.webkitRelativePath ? b.webkitRelativePath.split('/').pop() : '');
                        return fileNameA.localeCompare(fileNameB);
                    });
                });
            }
            
            // Hide loading state when done processing
            hideLoading();
            
            // Render all sessions
            renderAllSessions();
            if (sessions.length > 0) {
                document.getElementById('uploadControls').style.display = 'block';
                updateUploadUI();
            }
        }
        
        function renderAllSessions() {
            // Sort sessions by name (newest first)
            sessions.sort((a, b) => b.name.localeCompare(a.name));
            
            // Clear the container
            sessionsContainer.innerHTML = '';
            
            // Render each session
            sessions.forEach(session => {
                renderSession(session);
            });
            
            // Show/hide upload controls based on sessions
            if (sessions.length > 0) {
                document.getElementById('uploadControls').style.display = 'block';
                updateUploadUI();
            } else {
                document.getElementById('uploadControls').style.display = 'none';
            }
            
            // Add global event listener for log tabs using event delegation
            document.removeEventListener('click', handleLogTabClickDelegate);
            document.addEventListener('click', handleLogTabClickDelegate);
        }
        
        function renderSession(session) {
            if (!session || !session.name) {
                return;
            }
            
            // Debug the session structure
            console.log('Rendering session: ', session);
            console.log('Displays: ', Object.keys(session.displays));
            
            // Initialize selection state if it doesn't exist
            if (session.selected === undefined) {
                session.selected = true;
            }
            
            // Check for any display with chunks
            let hasAnyChunks = false;
            for (const key in session.displays) {
                const display = session.displays[key];
                
                // Initialize display selection state
                if (display.selected === undefined) {
                    display.selected = true;
                }
                
                // Initialize chunk selection state
                if (display.chunks && display.chunks.length > 0) {
                    display.chunks.forEach(chunk => {
                        if (chunk.selected === undefined) {
                            chunk.selected = true;
                        }
                    });
                    
                    hasAnyChunks = true;
                    console.log(`Display ${key} has ${display.chunks.length} chunks`);
                }
            }
            
            if (!hasAnyChunks) {
                console.log('No chunks found in any display');
            }
            
            const sessionView = document.createElement('div');
            sessionView.className = 'session-view';
            sessionView.dataset.sessionId = session.id;
            
            // Add a close button to remove this session and a checkbox for selection
            sessionView.innerHTML = `
                <div class="session-header">
                    <div class="session-title">
                        <input type="checkbox" id="session-${session.id}" 
                            class="selection-checkbox session-checkbox" 
                            data-session-id="${session.id}" 
                            ${session.selected ? 'checked' : ''}>
                        <h2 class="checkbox-label" for="session-${session.id}">Session: ${session.name}</h2>
                    </div>
                    <button class="btn-close" data-session-id="${session.id}">Ã—</button>
                </div>
            `;
            
            // Add close button event listener
            sessionView.querySelector('.btn-close').addEventListener('click', () => {
                // Remove this session
                const sessionIndex = sessions.findIndex(s => s.id === session.id);
                if (sessionIndex >= 0) {
                    sessions.splice(sessionIndex, 1);
                }
                
                // Remove from DOM
                sessionView.remove();
                
                // Update upload UI
                updateUploadUI();
                
                if (sessions.length === 0) {
                    showMessage('All sessions closed. Drop a new session folder to view.', 'notice');
                    document.getElementById('uploadControls').style.display = 'none';
                }
            });
            
            // Add session checkbox event listener
            const sessionCheckbox = sessionView.querySelector(`.session-checkbox[data-session-id="${session.id}"]`);
            sessionCheckbox.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                session.selected = isChecked;
                
                // Update all displays and chunks in this session
                for (const key in session.displays) {
                    const display = session.displays[key];
                    display.selected = isChecked;
                    
                    // Update display checkbox
                    const displayCheckbox = sessionView.querySelector(`.display-checkbox[data-display-key="${key}"]`);
                    if (displayCheckbox) {
                        displayCheckbox.checked = isChecked;
                    }
                    
                    // Update all chunk checkboxes for this display
                    if (display.chunks && display.chunks.length > 0) {
                        display.chunks.forEach((chunk, idx) => {
                            chunk.selected = isChecked;
                            const chunkCheckbox = sessionView.querySelector(`.chunk-checkbox[data-display-key="${key}"][data-chunk-index="${idx}"]`);
                            if (chunkCheckbox) {
                                chunkCheckbox.checked = isChecked;
                            }
                        });
                    }
                }
                
                // Update the upload UI
                updateUploadUI();
            });
            
            // Create display container
            const displayContainer = document.createElement('div');
            displayContainer.className = 'display-container';
            
            // Check if we have any displays with chunks
            let hasValidDisplays = false;
            
            // Get all display keys and convert to array
            const displayKeys = Object.keys(session.displays);
            
            // Add each display - use globally unique IDs based on session and display
            displayKeys.forEach((displayKey, displayIndex) => {
                const display = session.displays[displayKey];
                
                console.log(`Checking display ${displayKey}: ${display.chunks.length} chunks`);
                
                if (!display.chunks || display.chunks.length === 0) {
                    console.log(`Skipping display ${displayKey} - no chunks`);
                    return;
                }
                
                hasValidDisplays = true;
                console.log(`Adding display ${displayKey} with ${display.chunks.length} chunks`);
                
                // Create unique IDs for this display's elements
                const videoId = `videoPlayer-${session.id}-${displayIndex}`;
                const speedSelectId = `speedSelect-${session.id}-${displayIndex}`;
                const chunkListId = `chunkList-${session.id}-${displayIndex}`;
                
                const displayView = document.createElement('div');
                displayView.className = 'display-view';
                displayView.innerHTML = `
                    <div class="display-title">
                        <input type="checkbox" id="display-${session.id}-${displayKey}" 
                            class="selection-checkbox display-checkbox" 
                            data-session-id="${session.id}" 
                            data-display-key="${displayKey}" 
                            ${display.selected ? 'checked' : ''}>
                        <h3 class="checkbox-label" for="display-${session.id}-${displayKey}">${display.name}</h3>
                    </div>
                    <video id="${videoId}" controls></video>
                    <div class="controls">
                        <label>Playback Speed:</label>
                        <select id="${speedSelectId}" class="speed-select">
                            <option value="1">1x</option>
                            <option value="2">2x</option>
                            <option value="5">5x</option>
                            <option value="10">10x</option>
                            <option value="30">30x</option>
                            <option value="60" selected>60x</option>
                        </select>
                        <button class="sync-speeds">Sync All Speeds</button>
                    </div>
                    <ul id="${chunkListId}" class="chunk-list"></ul>
                    
                    <div class="log-tabs">
                        <div class="log-tab active" data-log-type="keystroke" data-display-id="${session.id}-${displayIndex}">Keystrokes</div>
                        <div class="log-tab" data-log-type="mouse" data-display-id="${session.id}-${displayIndex}">Mouse</div>
                    </div>
                    <div id="logContainer-${session.id}-${displayIndex}" class="log-container"></div>
                `;
                
                displayContainer.appendChild(displayView);
                
                // Add display checkbox event listener
                const displayCheckbox = displayView.querySelector('.display-checkbox');
                displayCheckbox.addEventListener('change', (e) => {
                    const isChecked = e.target.checked;
                    display.selected = isChecked;
                    
                    // Update all chunks in this display
                    if (display.chunks && display.chunks.length > 0) {
                        display.chunks.forEach((chunk, idx) => {
                            chunk.selected = isChecked;
                            
                            // Update chunk checkbox
                            const chunkCheckbox = displayView.querySelector(`.chunk-checkbox[data-chunk-index="${idx}"]`);
                            if (chunkCheckbox) {
                                chunkCheckbox.checked = isChecked;
                            }
                        });
                    }
                    
                    // Check if we need to update the session checkbox
                    let allDisplaysMatch = true;
                    for (const key in session.displays) {
                        if (session.displays[key].selected !== isChecked) {
                            allDisplaysMatch = false;
                            break;
                        }
                    }
                    
                    // If all displays match, update the session checkbox
                    if (allDisplaysMatch) {
                        session.selected = isChecked;
                        const sessionCheckbox = document.querySelector(`.session-checkbox[data-session-id="${session.id}"]`);
                        if (sessionCheckbox) {
                            sessionCheckbox.checked = isChecked;
                        }
                    }
                    
                    // Update the upload UI
                    updateUploadUI();
                });
                
                // Add chunks to the list with checkboxes
                const chunkList = displayView.querySelector(`#${chunkListId}`);
                display.chunks.forEach((chunk, chunkIndex) => {
                    const fileName = chunk.name || (chunk.webkitRelativePath ? chunk.webkitRelativePath.split('/').pop() : 'chunk');
                    const li = document.createElement('li');
                    li.className = 'chunk-list-item';
                    li.id = `chunkItem-${session.id}-${displayIndex}-${chunkIndex}`;
                    
                    // Add checkbox and chunk name
                    li.innerHTML = `
                        <input type="checkbox" id="chunk-${session.id}-${displayKey}-${chunkIndex}" 
                            class="selection-checkbox chunk-checkbox" 
                            data-session-id="${session.id}" 
                            data-display-key="${displayKey}" 
                            data-chunk-index="${chunkIndex}" 
                            ${chunk.selected ? 'checked' : ''}>
                        <span class="checkbox-label" for="chunk-${session.id}-${displayKey}-${chunkIndex}">${fileName}</span>
                    `;
                    
                    chunkList.appendChild(li);
                    
                    // Add chunk checkbox event listener
                    const chunkCheckbox = li.querySelector('.chunk-checkbox');
                    chunkCheckbox.addEventListener('change', (e) => {
                        const isChecked = e.target.checked;
                        chunk.selected = isChecked;
                        
                        // Check if we need to update the display checkbox
                        let allChunksMatch = true;
                        display.chunks.forEach(c => {
                            if (c.selected !== isChecked) {
                                allChunksMatch = false;
                            }
                        });
                        
                        // If all chunks match, update the display checkbox
                        if (allChunksMatch) {
                            display.selected = isChecked;
                            const displayCheckbox = displayView.querySelector(`.display-checkbox[data-display-key="${displayKey}"]`);
                            if (displayCheckbox) {
                                displayCheckbox.checked = isChecked;
                            }
                            
                            // Also check if we need to update the session checkbox
                            let allDisplaysMatch = true;
                            for (const key in session.displays) {
                                if (session.displays[key].selected !== isChecked) {
                                    allDisplaysMatch = false;
                                    break;
                                }
                            }
                            
                            // If all displays match, update the session checkbox
                            if (allDisplaysMatch) {
                                session.selected = isChecked;
                                const sessionCheckbox = document.querySelector(`.session-checkbox[data-session-id="${session.id}"]`);
                                if (sessionCheckbox) {
                                    sessionCheckbox.checked = isChecked;
                                }
                            }
                        }
                        
                        // Update the upload UI
                        updateUploadUI();
                    });
                    
                    // Make the chunk clickable for video playback (clicking on the text, not the checkbox)
                    li.querySelector('span').addEventListener('click', () => {
                        const videoId = `videoPlayer-${session.id}-${displayIndex}`;
                        const videoPlayer = document.getElementById(videoId);
                        if (!videoPlayer) return;
                        
                        // Store current speed
                        const currentSpeed = videoPlayer.playbackRate;
                        
                        // Update current chunk index
                        window.currentChunkIndexes = window.currentChunkIndexes || {};
                        const uniqueDisplayKey = `${session.id}-${displayIndex}`;
                        window.currentChunkIndexes[uniqueDisplayKey] = chunkIndex;
                        
                        // Load this chunk
                        const videoURL = URL.createObjectURL(chunk);
                        videoPlayer.src = videoURL;
                        
                        // Set playback rate after loading
                        videoPlayer.addEventListener('loadedmetadata', function onLoad() {
                            videoPlayer.playbackRate = currentSpeed;
                            videoPlayer.removeEventListener('loadedmetadata', onLoad);
                        });
                        
                        videoPlayer.play();
                        
                        // Update highlight
                        document.querySelectorAll(`#${chunkListId} .chunk-highlight`).forEach(el => {
                            el.classList.remove('chunk-highlight');
                        });
                        li.classList.add('chunk-highlight');
                    });
                });
            });
            
            if (!hasValidDisplays) {
                displayContainer.innerHTML = `
                    <div class="no-displays">
                        <p>No displays with video chunks found in this session</p>
                    </div>
                `;
            }
            
            sessionView.appendChild(displayContainer);
            sessionsContainer.appendChild(sessionView);
            
            // Initialize video players and event handlers
            if (hasValidDisplays) {
                initializeVideoPlayers(session);
                // Initialize log displays
                updateLogDisplays(session);
                // Show upload controls
                document.getElementById('uploadControls').style.display = 'block';
                // Update upload UI
                updateUploadUI();
            }
        }
        
        function updateChunkLists(session) {
            // This function is called to update chunk lists when new chunks are added
            console.log('Updating chunk lists for session', session.id);
            
            const displayKeys = Object.keys(session.displays);
            
            displayKeys.forEach((displayKey, displayIndex) => {
                const display = session.displays[displayKey];
                console.log(`Updating chunks for display ${displayKey} with ${display.chunks.length} chunks`);
                
                const chunkListId = `chunkList-${session.id}-${displayIndex}`;
                const chunkList = document.getElementById(chunkListId);
                if (!chunkList) {
                    console.log(`Chunk list element not found: ${chunkListId}`);
                    return;
                }
                
                // Clear existing list
                chunkList.innerHTML = '';
                
                // Add current chunks
                display.chunks.forEach((chunk, chunkIndex) => {
                    // Initialize chunk selection state if it doesn't exist
                    if (chunk.selected === undefined) {
                        chunk.selected = true;
                    }
                    
                    const fileName = chunk.name || (chunk.webkitRelativePath ? chunk.webkitRelativePath.split('/').pop() : 'chunk');
                    const li = document.createElement('li');
                    li.className = 'chunk-list-item';
                    li.id = `chunkItem-${session.id}-${displayIndex}-${chunkIndex}`;
                    
                    // Add checkbox and chunk name
                    li.innerHTML = `
                        <input type="checkbox" id="chunk-${session.id}-${displayKey}-${chunkIndex}" 
                            class="selection-checkbox chunk-checkbox" 
                            data-session-id="${session.id}" 
                            data-display-key="${displayKey}" 
                            data-chunk-index="${chunkIndex}" 
                            ${chunk.selected ? 'checked' : ''}>
                        <span class="checkbox-label" for="chunk-${session.id}-${displayKey}-${chunkIndex}">${fileName}</span>
                    `;
                    
                    chunkList.appendChild(li);
                    
                    // Add chunk checkbox event listener
                    const chunkCheckbox = li.querySelector('.chunk-checkbox');
                    chunkCheckbox.addEventListener('change', (e) => {
                        const isChecked = e.target.checked;
                        chunk.selected = isChecked;
                        
                        // Check if we need to update the display checkbox
                        let allChunksMatch = true;
                        display.chunks.forEach(c => {
                            if (c.selected !== isChecked) {
                                allChunksMatch = false;
                            }
                        });
                        
                        // If all chunks match, update the display checkbox
                        if (allChunksMatch) {
                            display.selected = isChecked;
                            const displayCheckbox = document.querySelector(`.display-checkbox[data-display-key="${displayKey}"]`);
                            if (displayCheckbox) {
                                displayCheckbox.checked = isChecked;
                            }
                            
                            // Also check if we need to update the session checkbox
                            let allDisplaysMatch = true;
                            for (const key in session.displays) {
                                if (session.displays[key].selected !== isChecked) {
                                    allDisplaysMatch = false;
                                    break;
                                }
                            }
                            
                            // If all displays match, update the session checkbox
                            if (allDisplaysMatch) {
                                session.selected = isChecked;
                                const sessionCheckbox = document.querySelector(`.session-checkbox[data-session-id="${session.id}"]`);
                                if (sessionCheckbox) {
                                    sessionCheckbox.checked = isChecked;
                                }
                            }
                        }
                        
                        // Update the upload UI
                        updateUploadUI();
                    });
                    
                    // Make the chunk clickable for video playback (clicking on the text, not the checkbox)
                    li.querySelector('span').addEventListener('click', () => {
                        const videoId = `videoPlayer-${session.id}-${displayIndex}`;
                        const videoPlayer = document.getElementById(videoId);
                        if (!videoPlayer) return;
                        
                        // Store current speed
                        const currentSpeed = videoPlayer.playbackRate;
                        
                        // Update current chunk index
                        window.currentChunkIndexes = window.currentChunkIndexes || {};
                        const uniqueDisplayKey = `${session.id}-${displayIndex}`;
                        window.currentChunkIndexes[uniqueDisplayKey] = chunkIndex;
                        
                        // Load this chunk
                        const videoURL = URL.createObjectURL(chunk);
                        videoPlayer.src = videoURL;
                        
                        // Set playback rate after loading
                        videoPlayer.addEventListener('loadedmetadata', function onLoad() {
                            videoPlayer.playbackRate = currentSpeed;
                            videoPlayer.removeEventListener('loadedmetadata', onLoad);
                        });
                        
                        videoPlayer.play();
                        
                        // Update highlight
                        document.querySelectorAll(`#${chunkListId} .chunk-highlight`).forEach(el => {
                            el.classList.remove('chunk-highlight');
                        });
                        li.classList.add('chunk-highlight');
                    });
                });
                
                // Highlight current chunk if known
                if (window.currentChunkIndexes) {
                    const uniqueDisplayKey = `${session.id}-${displayIndex}`;
                    if (window.currentChunkIndexes[uniqueDisplayKey] !== undefined) {
                        const currentIdx = window.currentChunkIndexes[uniqueDisplayKey];
                        const currentItem = document.getElementById(`chunkItem-${session.id}-${displayIndex}-${currentIdx}`);
                        if (currentItem) {
                            currentItem.classList.add('chunk-highlight');
                        }
                    }
                }
                
                // Default: highlight first chunk if none is currently highlighted
                if (!chunkList.querySelector('.chunk-highlight') && chunkList.children.length > 0) {
                    chunkList.children[0].classList.add('chunk-highlight');
                }
            });
            
            // Update upload UI to reflect changes
            updateUploadUI();
        }
        
        function initializeVideoPlayers(session) {
            console.log('Initializing video players for session', session.id);
        
            // For each display with chunks
            const displayKeys = Object.keys(session.displays);
            
            displayKeys.forEach((displayKey, displayIndex) => {
                const display = session.displays[displayKey];
                console.log(`Initializing player for display ${displayKey} with ${display.chunks.length} chunks`);
                
                if (display.chunks.length === 0) {
                    return;
                }
                
                const videoId = `videoPlayer-${session.id}-${displayIndex}`;
                const speedSelectId = `speedSelect-${session.id}-${displayIndex}`;
                const chunkListId = `chunkList-${session.id}-${displayIndex}`;
                
                const videoPlayer = document.getElementById(videoId);
                const speedSelect = document.getElementById(speedSelectId);
                const chunkList = document.getElementById(chunkListId);
                
                if (!videoPlayer || !speedSelect || !chunkList) {
                    return;
                }
                
                // Set up video player with the first chunk
                const firstChunk = display.chunks[0];
                const videoURL = URL.createObjectURL(firstChunk);
                videoPlayer.src = videoURL;
                
                // Initialize variables - store them in a global map
                window.currentChunkIndexes = window.currentChunkIndexes || {};
                const uniqueDisplayKey = `${session.id}-${displayIndex}`;
                window.currentChunkIndexes[uniqueDisplayKey] = 0;
                
                // Update log display for initial chunk
                updateLogDisplays(session, displayIndex, 0);
                
                // Set initial playback speed
                videoPlayer.playbackRate = parseFloat(speedSelect.value);
                
                // Handle speed changes
                speedSelect.addEventListener('change', () => {
                    videoPlayer.playbackRate = parseFloat(speedSelect.value);
                });
                
                // Handle video end - play next chunk if available
                videoPlayer.addEventListener('ended', () => {
                    window.currentChunkIndexes[uniqueDisplayKey]++;
                    const currentChunkIndex = window.currentChunkIndexes[uniqueDisplayKey];
                    
                    if (currentChunkIndex < display.chunks.length) {
                        // Store current speed
                        const currentSpeed = videoPlayer.playbackRate;
                        
                        // Load next chunk
                        const nextChunk = display.chunks[currentChunkIndex];
                        const videoURL = URL.createObjectURL(nextChunk);
                        videoPlayer.src = videoURL;
                        
                        // Need to wait for the new source to load before setting playback rate
                        videoPlayer.addEventListener('loadedmetadata', function onLoad() {
                            videoPlayer.playbackRate = currentSpeed;
                            videoPlayer.removeEventListener('loadedmetadata', onLoad);
                        });
                        
                        videoPlayer.play();
                        
                        // Update highlight
                        document.querySelectorAll(`#${chunkListId} .chunk-highlight`).forEach(el => {
                            el.classList.remove('chunk-highlight');
                        });
                        document.getElementById(`chunkItem-${session.id}-${displayIndex}-${currentChunkIndex}`).classList.add('chunk-highlight');
                        
                        // Update log display for the new chunk
                        updateLogDisplays(session, displayIndex, currentChunkIndex);
                    }
                });
                
                // Initial highlight
                document.getElementById(`chunkItem-${session.id}-${displayIndex}-0`).classList.add('chunk-highlight');
                
                // Make chunks clickable to jump to them
                document.querySelectorAll(`#${chunkListId} .chunk-list-item`).forEach((item, idx) => {
                    item.addEventListener('click', () => {
                        // Store current speed
                        const currentSpeed = videoPlayer.playbackRate;
                        
                        // Update current chunk index
                        window.currentChunkIndexes[uniqueDisplayKey] = idx;
                        
                        // Load this chunk
                        const chunk = display.chunks[idx];
                        const videoURL = URL.createObjectURL(chunk);
                        videoPlayer.src = videoURL;
                        
                        // Need to wait for the new source to load before setting playback rate
                        videoPlayer.addEventListener('loadedmetadata', function onLoad() {
                            videoPlayer.playbackRate = currentSpeed;
                            videoPlayer.removeEventListener('loadedmetadata', onLoad);
                        });
                        
                        videoPlayer.play();
                        
                        // Update highlight
                        document.querySelectorAll(`#${chunkListId} .chunk-highlight`).forEach(el => {
                            el.classList.remove('chunk-highlight');
                        });
                        item.classList.add('chunk-highlight');
                        
                        // Update log display for the selected chunk
                        updateLogDisplays(session, displayIndex, idx);
                    });
                });
            });
            
            // Set up Sync All Speeds buttons for this session
            const sessionElement = document.querySelector(`[data-session-id="${session.id}"]`);
            if (sessionElement) {
                const syncButtons = sessionElement.querySelectorAll('.sync-speeds');
                syncButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        // Get all speed selects within this session
                        const speedSelects = sessionElement.querySelectorAll('.speed-select');
                        if (speedSelects.length > 0) {
                            const firstSpeed = speedSelects[0].value;
                            speedSelects.forEach(select => {
                                select.value = firstSpeed;
                                select.dispatchEvent(new Event('change'));
                            });
                        }
                    });
                });
            }
        }
        
        function updateLogDisplays(session, targetDisplayIndex = null, targetChunkIndex = null) {
            console.log('Updating log displays for session', session.id);
            
            // Skip if there are no logs
            if (!session.logs || (!session.logs.keystroke.length && !session.logs.mouse.length)) {
                console.log('No logs to display for session', session.id);
                return;
            }
            
            const displayKeys = Object.keys(session.displays);
            
            displayKeys.forEach((displayKey, displayIndex) => {
                // Skip if we're targeting a specific display and this isn't it
                if (targetDisplayIndex !== null && displayIndex !== targetDisplayIndex) {
                    return;
                }
                
                const display = session.displays[displayKey];
                const logContainerId = `logContainer-${session.id}-${displayIndex}`;
                const logContainer = document.getElementById(logContainerId);
                
                if (!logContainer) {
                    console.log(`Log container element not found: ${logContainerId}`);
                    return;
                }
                
                // Get the active log type from the tabs
                const activeTab = document.querySelector(`.log-tab.active[data-display-id="${session.id}-${displayIndex}"]`);
                if (!activeTab) {
                    console.log(`No active tab found for display ${session.id}-${displayIndex}`);
                    return;
                }
                
                const logType = activeTab.dataset.logType;
                console.log(`Updating log display for ${logType} logs on display ${displayIndex}`);
                
                // Get logs from the session (not the display)
                const logs = session.logs[logType] || [];
                
                // Clear existing content
                logContainer.innerHTML = '';
                
                if (logs.length === 0) {
                    logContainer.innerHTML = `<div class="no-logs">No ${logType} logs found for this session</div>`;
                    return;
                }
                
                // Get the current chunk index for this display
                const uniqueDisplayKey = `${session.id}-${displayIndex}`;
                const currentChunkIndex = targetChunkIndex !== null ? 
                    targetChunkIndex : 
                    (window.currentChunkIndexes && window.currentChunkIndexes[uniqueDisplayKey]) || 0;
                
                // Determine time range for the current chunk
                // Each chunk is 60 seconds, calculate absolute start and end timestamps
                const chunkDuration = 60; // seconds
                const frameTimestamps = display.frameTimestamps || [];
                let chunkStartTime, chunkEndTime;
                
                if (frameTimestamps.length > 0) {
                    // Calculate start and end frames for this chunk
                    const framesPerChunk = 1800; // 30fps * 60s
                    const startFrameIndex = currentChunkIndex * framesPerChunk;
                    const endFrameIndex = Math.min((currentChunkIndex + 1) * framesPerChunk - 1, frameTimestamps.length - 1);
                    
                    // Get timestamps from frames.log if available
                    if (startFrameIndex < frameTimestamps.length) {
                        chunkStartTime = frameTimestamps[startFrameIndex];
                        chunkEndTime = frameTimestamps[endFrameIndex];
                    } else {
                        // Fallback if frames.log doesn't have data for this chunk
                        const firstLogTime = logs[0].timestamp;
                        const lastLogTime = logs[logs.length - 1].timestamp;
                        const totalDuration = Math.ceil((lastLogTime - firstLogTime) / 1000); // in seconds
                        const totalChunks = Math.ceil(totalDuration / chunkDuration);
                        
                        // Calculate normalized time range for this chunk
                        const chunkStartPercent = currentChunkIndex / totalChunks;
                        const chunkEndPercent = (currentChunkIndex + 1) / totalChunks;
                        
                        chunkStartTime = firstLogTime + (chunkStartPercent * (lastLogTime - firstLogTime));
                        chunkEndTime = firstLogTime + (chunkEndPercent * (lastLogTime - firstLogTime));
                    }
                } else {
                    // No frame timestamps, estimate based on log timestamps
                    const firstLogTime = logs[0].timestamp;
                    const lastLogTime = logs[logs.length - 1].timestamp;
                    const totalDuration = Math.ceil((lastLogTime - firstLogTime) / 1000); // in seconds
                    const totalChunks = Math.ceil(totalDuration / chunkDuration);
                    
                    // Calculate normalized time range for this chunk
                    const chunkStartPercent = currentChunkIndex / totalChunks;
                    const chunkEndPercent = (currentChunkIndex + 1) / totalChunks;
                    
                    chunkStartTime = firstLogTime + (chunkStartPercent * (lastLogTime - firstLogTime));
                    chunkEndTime = firstLogTime + (chunkEndPercent * (lastLogTime - firstLogTime));
                }
                
                // Filter logs to only show those in the current chunk's time range
                const chunkLogs = logs.filter(log => 
                    log.timestamp >= chunkStartTime && log.timestamp <= chunkEndTime
                );
                
                console.log(`Display ${displayIndex}, Chunk ${currentChunkIndex}: Showing ${chunkLogs.length} of ${logs.length} logs`);
                
                // Display chunk time range for reference
                if (chunkStartTime !== undefined && chunkEndTime !== undefined) {
                    const startTimeRelative = formatTimestamp(chunkStartTime, logs[0].timestamp);
                    const endTimeRelative = formatTimestamp(chunkEndTime, logs[0].timestamp);
                    const timeRangeHeader = document.createElement('div');
                    timeRangeHeader.className = 'time-range-header';
                    timeRangeHeader.innerHTML = `Showing logs for chunk ${currentChunkIndex} (${startTimeRelative} - ${endTimeRelative})`;
                    logContainer.appendChild(timeRangeHeader);
                }
                
                if (chunkLogs.length === 0) {
                    logContainer.innerHTML += `<div class="no-logs">No ${logType} logs in this chunk</div>`;
                    return;
                }
                
                // Sort logs by timestamp if they have one
                chunkLogs.sort((a, b) => a.timestamp - b.timestamp);
                
                // Add log entries for this chunk
                chunkLogs.forEach((log, index) => {
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry ${logType}`;
                    logEntry.dataset.index = index;
                    logEntry.dataset.timestamp = log.timestamp || 0;
                    
                    // Format timestamp as relative time from the start (if available)
                    let relativeTime = '';
                    if (logs[0].timestamp !== undefined && log.timestamp !== undefined) {
                        relativeTime = formatTimestamp(log.timestamp, logs[0].timestamp);
                    } else if (log.time) {
                        // Alternative timestamp format
                        relativeTime = log.time;
                    }
                    
                    if (logType === 'keystroke') {
                        // Format keystroke entry - adapt this to your actual log format
                        let keyText = '';
                        let modifiers = [];
                        
                        // New format handling
                        if (log.state) {
                            // Log from the custom format
                            if (log.state === 'none') {
                                keyText = 'None';
                            } else if (log.key) {
                                keyText = log.key;
                                
                                // Use existing modifiers if available
                                if (log.modifiers) {
                                    modifiers = log.modifiers;
                                }
                            } else {
                                keyText = log.state.replace(/^\+/, '');
                            }
                        } 
                        // Fallback to original format handling
                        else if (log.key) {
                            keyText = log.key;
                        } else if (log.keycode) {
                            keyText = String.fromCharCode(log.keycode);
                        } else if (log.keyCode) {
                            keyText = String.fromCharCode(log.keyCode);
                        } else if (log.code) {
                            keyText = log.code;
                        } else if (log.char) {
                            keyText = log.char;
                        }
                        
                        // Try to extract modifiers if not already set
                        if (modifiers.length === 0) {
                            if (log.modifiers) {
                                modifiers = log.modifiers;
                            } else {
                                // Extract from individual modifier flags
                                if (log.shift || log.shiftKey) modifiers.push('shift');
                                if (log.ctrl || log.ctrlKey) modifiers.push('ctrl');
                                if (log.alt || log.altKey) modifiers.push('alt');
                                if (log.meta || log.metaKey) modifiers.push('meta');
                            }
                        }
                        
                        // Format key nicely
                        if (keyText === ' ') keyText = 'Space';
                        if (keyText === 'Enter') keyText = 'âŽ';
                        if (keyText === 'Backspace') keyText = 'âŒ«';
                        if (keyText === 'Tab') keyText = 'â‡¥';
                        if (keyText === 'Escape') keyText = 'Esc';
                        if (keyText === 'ArrowUp') keyText = 'â†‘';
                        if (keyText === 'ArrowDown') keyText = 'â†“';
                        if (keyText === 'ArrowLeft') keyText = 'â†';
                        if (keyText === 'ArrowRight') keyText = 'â†’';
                        
                        // Specific handling for keys from our custom format
                        if (keyText.startsWith('Key')) {
                            keyText = keyText.substring(3); // Remove 'Key' prefix
                        } else if (keyText.startsWith('Digit')) {
                            keyText = keyText.substring(5); // Remove 'Digit' prefix
                        }
                        
                        // Format modifiers
                        let modifierText = '';
                        if (modifiers.includes('shift')) modifierText += 'Shift+';
                        if (modifiers.includes('ctrl') || modifiers.includes('control')) modifierText += 'Ctrl+';
                        if (modifiers.includes('alt')) modifierText += 'Alt+';
                        if (modifiers.includes('meta') || modifiers.includes('command')) modifierText += 'âŒ˜+';
                        
                        // Create display
                        const keyIndicator = document.createElement('span');
                        keyIndicator.className = 'key-indicator';
                        keyIndicator.textContent = modifierText + keyText;
                        
                        logEntry.innerHTML = `<span class="log-timestamp">${relativeTime}</span>`;
                        logEntry.appendChild(keyIndicator);
                        
                        // Check if we have an action/type field or if it's a keyup/keydown
                        // For our custom format, we don't have explicit keyup/keydown
                        // We just have states, so let's show the state
                        if (log.state === 'none') {
                            logEntry.appendChild(document.createTextNode(' (no keys pressed)'));
                        } else if (log.action === 'keyup' || log.type === 'keyup') {
                            logEntry.appendChild(document.createTextNode(' released'));
                        } else {
                            logEntry.appendChild(document.createTextNode(' pressed'));
                        }
                        
                        // Add raw log data as a tooltip for debugging
                        logEntry.title = JSON.stringify(log);
                        
                    } else if (logType === 'mouse') {
                        // Format mouse entry based on our custom format
                        let action = 'move';
                        let x = '';
                        let y = '';
                        let extraInfo = '';
                        
                        // Try to extract action/type
                        if (log.action) {
                            action = log.action;
                        } else if (log.type) {
                            action = log.type;
                        } else if (log.button !== undefined) {
                            action = `click button ${log.button}`;
                        }
                        
                        // Try to extract coordinates
                        if (log.x !== undefined) {
                            x = log.x.toFixed(0);
                            y = log.y !== undefined ? log.y.toFixed(0) : '';
                        } else if (log.clientX !== undefined) {
                            x = log.clientX.toFixed(0);
                            y = log.clientY !== undefined ? log.clientY.toFixed(0) : '';
                        } else if (log.screenX !== undefined) {
                            x = log.screenX.toFixed(0);
                            y = log.screenY !== undefined ? log.screenY.toFixed(0) : '';
                        }
                        
                        // Handle deltas
                        if (log.deltaX !== undefined || log.deltaY !== undefined) {
                            const dx = log.deltaX !== undefined ? log.deltaX.toFixed(0) : '0';
                            const dy = log.deltaY !== undefined ? log.deltaY.toFixed(0) : '0';
                            extraInfo = ` (delta: ${dx}, ${dy})`;
                        }
                        
                        let displayText = '';
                        
                        if (action === 'move' && x && y) {
                            displayText = `Mouse ${action} at x:${x}, y:${y}`;
                        } else if (action === 'delta' && extraInfo) {
                            displayText = `Mouse delta${extraInfo}`;
                        } else if (action === 'button' && log.button) {
                            displayText = `Mouse button ${log.button} ${log.action || 'clicked'}`;
                        } else if (action === 'wheel') {
                            displayText = `Mouse wheel${extraInfo}`;
                        } else {
                            displayText = `Mouse ${action}`;
                            if (x && y) {
                                displayText += ` at x:${x}, y:${y}`;
                            }
                            if (extraInfo) {
                                displayText += extraInfo;
                            }
                        }
                        
                        logEntry.innerHTML = `
                            <span class="log-timestamp">${relativeTime}</span>
                            ${displayText}
                        `;
                        
                        // Add raw log data as a tooltip for debugging
                        logEntry.title = JSON.stringify(log);
                    }
                    
                    logContainer.appendChild(logEntry);
                });
            });
        }
        
        // Event delegation for tab clicks
        function handleLogTabClickDelegate(e) {
            // Find the closest tab element (handles clicking on child elements)
            const tab = e.target.closest('.log-tab');
            if (!tab) return; // Not a tab click
            
            const displayId = tab.dataset.displayId;
            const logType = tab.dataset.logType;
            
            console.log(`Tab click detected: ${logType} for display ${displayId}`);
            
            // Skip if already active
            if (tab.classList.contains('active')) {
                console.log('Tab already active, skipping');
                return;
            }
            
            // Deactivate all tabs for this display
            document.querySelectorAll(`.log-tab[data-display-id="${displayId}"]`).forEach(t => {
                t.classList.remove('active');
            });
            
            // Activate this tab
            tab.classList.add('active');
            
            // Parse session and display index from displayId
            const [sessionId, displayIndex] = displayId.split('-');
            
            // Find the session
            const session = sessions.find(s => s.id === sessionId);
            if (session) {
                // Update log display with specific display index
                updateLogDisplays(session, parseInt(displayIndex));
                console.log(`Switched to ${logType} logs for display ${displayIndex} in session ${sessionId}`);
            } else {
                console.error(`Session not found for ID: ${sessionId}`);
            }
        }
        
        // Helper function to format timestamps
        function formatTimestamp(timestamp, baseTimestamp) {
            const relativeMs = timestamp - baseTimestamp;
            const seconds = Math.floor(relativeMs / 1000);
            const ms = relativeMs % 1000;
            
            if (seconds === 0) {
                return `${ms}ms`;
            } else {
                return `${seconds}.${ms.toString().padStart(3, '0')}s`;
            }
        }
        
        function showMessage(message, type = 'notice') {
            messageArea.innerHTML = `<div class="message ${type}">${message}</div>`;
            setTimeout(() => {
                messageArea.innerHTML = '';
            }, 5000);
        }

        // Add some CSS for the time range header
        function addStyles() {
            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .time-range-header {
                    padding: 5px;
                    background-color: #f1f3f5;
                    border-radius: 4px;
                    margin-bottom: 10px;
                    font-weight: bold;
                    color: #495057;
                    text-align: center;
                }
            `;
            document.head.appendChild(styleElement);
        }

        // Call this when the page loads
        window.addEventListener('DOMContentLoaded', function() {
            addStyles();
            
            // Add event listener for upload button
            document.getElementById('uploadButton').addEventListener('click', handleUpload);
        });
        
        /**
         * Update the upload UI based on selected items
         */
        function updateUploadUI() {
            let totalSessions = 0;
            let selectedSessions = 0;
            
            let totalDisplays = 0;
            let selectedDisplays = 0;
            
            let totalChunks = 0;
            let selectedChunks = 0;
            
            // Count all selected items
            sessions.forEach(session => {
                totalSessions++;
                if (session.selected) {
                    selectedSessions++;
                }
                
                for (const key in session.displays) {
                    const display = session.displays[key];
                    if (display.chunks && display.chunks.length > 0) {
                        totalDisplays++;
                        if (display.selected) {
                            selectedDisplays++;
                        }
                        
                        display.chunks.forEach(chunk => {
                            totalChunks++;
                            if (chunk.selected) {
                                selectedChunks++;
                            }
                        });
                    }
                }
            });
            
            // Update selection summary
            const selectionSummary = document.getElementById('selectionSummary');
            const uploadButton = document.getElementById('uploadButton');
            
            if (totalSessions === 0) {
                selectionSummary.innerHTML = '<p>No items available for upload.</p>';
                uploadButton.disabled = true;
                return;
            }
            
            if (selectedSessions === 0) {
                selectionSummary.innerHTML = '<p>No items selected for upload.</p>';
                uploadButton.disabled = true;
                return;
            }
            
            selectionSummary.innerHTML = `
                <p>
                    <strong>Sessions:</strong> ${selectedSessions} of ${totalSessions} selected<br>
                    <strong>Displays:</strong> ${selectedDisplays} of ${totalDisplays} selected<br>
                    <strong>Chunks:</strong> ${selectedChunks} of ${totalChunks} selected
                </p>
            `;
            
            // Enable upload button if at least one item is selected
            uploadButton.disabled = selectedChunks === 0;
        }
        
        /**
         * Filter log files based on selected chunks
         * This is the crucial function for precise filtering
         */
        function filterLogsByChunks(session) {
            console.log(`DEBUG: Starting log filtering for session ${session.name}`);
            
            const filteredLogs = {
                keystroke: [],
                mouse: []
            };
            
            if (!session.logs) {
                console.log(`DEBUG: No logs found for session ${session.name}`);
                return filteredLogs;
            }
            
            // Get all selected time ranges from the chunks
            const selectedTimeRanges = [];
            
            // Log the total counts before filtering
            console.log(`DEBUG: Before filtering - Keystroke logs: ${session.logs.keystroke?.length || 0}, Mouse logs: ${session.logs.mouse?.length || 0}`);
            
            // Track data for each display
            const displayStats = {};
            
            for (const displayKey in session.displays) {
                const display = session.displays[displayKey];
                displayStats[displayKey] = {
                    name: display.name,
                    selected: display.selected,
                    chunkCount: display.chunks?.length || 0,
                    selectedChunkCount: 0,
                    timeRanges: []
                };
                
                // Skip unselected displays
                if (!display.selected) {
                    console.log(`DEBUG: Display ${display.name} is unselected, skipping`);
                    continue;
                }
                
                if (!display.chunks || display.chunks.length === 0) {
                    console.log(`DEBUG: Display ${display.name} has no chunks, skipping`);
                    continue;
                }
                
                // Get frame timestamps if available
                const frameTimestamps = display.frameTimestamps || [];
                console.log(`DEBUG: Display ${display.name} has ${frameTimestamps.length} frame timestamps`);
                
                // For each selected chunk, calculate its time range
                display.chunks.forEach((chunk, chunkIndex) => {
                    // Track if using frames or estimation
                    const method = frameTimestamps.length > 0 ? "frames" : "estimation";
                    
                    // Skip unselected chunks
                    if (!chunk.selected) {
                        console.log(`DEBUG: Chunk ${chunkIndex} (${chunk.name || 'unnamed'}) from ${display.name} is unselected`);
                        return; // Changed from 'continue' to 'return' to fix linter error
                    }
                    
                    displayStats[displayKey].selectedChunkCount++;
                    
                    // Determine time range for this chunk
                    const chunkDuration = 60; // seconds
                    let chunkStartTime, chunkEndTime;
                    
                    if (frameTimestamps.length > 0) {
                        // Calculate start and end frames for this chunk
                        const framesPerChunk = 1800; // 30fps * 60s
                        const startFrameIndex = chunkIndex * framesPerChunk;
                        const endFrameIndex = Math.min((chunkIndex + 1) * framesPerChunk - 1, frameTimestamps.length - 1);
                        
                        // Get timestamps from frames.log if available
                        if (startFrameIndex < frameTimestamps.length) {
                            chunkStartTime = frameTimestamps[startFrameIndex];
                            chunkEndTime = frameTimestamps[endFrameIndex];
                            console.log(`DEBUG: Chunk ${chunkIndex} time range from frames - start: ${new Date(chunkStartTime).toISOString()}, end: ${new Date(chunkEndTime).toISOString()}`);
                        } else {
                            // If we don't have frame info for this chunk, skip it
                            console.log(`DEBUG: No frame data for chunk ${chunkIndex}, skipping (startFrameIndex: ${startFrameIndex}, frameTimestamps.length: ${frameTimestamps.length})`);
                            return;
                        }
                    } else {
                        // No frame timestamps, estimate based on log timestamps
                        // This is less accurate, but better than nothing
                        const firstLogTime = session.logs.keystroke.length > 0 ? 
                            session.logs.keystroke[0].timestamp : 
                            (session.logs.mouse.length > 0 ? session.logs.mouse[0].timestamp : 0);
                            
                        const lastLogTime = session.logs.keystroke.length > 0 ? 
                            session.logs.keystroke[session.logs.keystroke.length - 1].timestamp : 
                            (session.logs.mouse.length > 0 ? session.logs.mouse[session.logs.mouse.length - 1].timestamp : 0);
                        
                        if (firstLogTime === 0 || lastLogTime === 0) {
                            console.log(`DEBUG: No valid log timestamps for estimation, skipping chunk ${chunkIndex}`);
                            return; // No valid log timestamps
                        }
                        
                        const totalDuration = Math.ceil((lastLogTime - firstLogTime) / 1000); // in seconds
                        const totalChunks = Math.ceil(totalDuration / chunkDuration);
                        
                        // Calculate normalized time range for this chunk
                        const chunkStartPercent = chunkIndex / totalChunks;
                        const chunkEndPercent = (chunkIndex + 1) / totalChunks;
                        
                        chunkStartTime = firstLogTime + (chunkStartPercent * (lastLogTime - firstLogTime));
                        chunkEndTime = firstLogTime + (chunkEndPercent * (lastLogTime - firstLogTime));
                        console.log(`DEBUG: Chunk ${chunkIndex} time range estimated - start: ${new Date(chunkStartTime).toISOString()}, end: ${new Date(chunkEndTime).toISOString()}`);
                        console.log(`DEBUG: Estimation details - firstLogTime: ${firstLogTime}, lastLogTime: ${lastLogTime}, totalDuration: ${totalDuration}s, totalChunks: ${totalChunks}`);
                    }
                    
                    // Add this time range
                    if (chunkStartTime !== undefined && chunkEndTime !== undefined) {
                        const timeRange = {
                            start: chunkStartTime,
                            end: chunkEndTime,
                            displayKey: displayKey,
                            displayName: display.name,
                            chunkIndex: chunkIndex,
                            chunkName: chunk.name || `Chunk ${chunkIndex+1}`,
                            method: method
                        };
                        
                        selectedTimeRanges.push(timeRange);
                        displayStats[displayKey].timeRanges.push(timeRange);
                    }
                });
            }
            
            console.log(`DEBUG: Created ${selectedTimeRanges.length} selected time ranges`);
            
            // Sort time ranges by start time
            selectedTimeRanges.sort((a, b) => a.start - b.start);
            
            // Merge overlapping time ranges
            const mergedTimeRanges = [];
            if (selectedTimeRanges.length > 0) {
                let currentRange = {...selectedTimeRanges[0]};
                
                for (let i = 1; i < selectedTimeRanges.length; i++) {
                    const nextRange = selectedTimeRanges[i];
                    
                    // If ranges overlap or are adjacent, merge them
                    if (nextRange.start <= currentRange.end) {
                        // Keep the later end time
                        currentRange.end = Math.max(currentRange.end, nextRange.end);
                        currentRange.chunkName += ` + ${nextRange.chunkName}`;
                        console.log(`DEBUG: Merged overlapping time ranges: ${new Date(currentRange.start).toISOString()} - ${new Date(currentRange.end).toISOString()}`);
                    } else {
                        // No overlap, add current range to merged list and start a new one
                        mergedTimeRanges.push(currentRange);
                        currentRange = {...nextRange};
                    }
                }
                
                // Add the last range
                mergedTimeRanges.push(currentRange);
            }
            
            console.log(`DEBUG: After merging, ${mergedTimeRanges.length} time ranges remain`);
            
            // Log all time ranges
            mergedTimeRanges.forEach((range, idx) => {
                console.log(`DEBUG: Time range ${idx+1}: ${new Date(range.start).toISOString()} - ${new Date(range.end).toISOString()} (${(range.end - range.start)/1000}s) from ${range.displayName} - ${range.chunkName}`);
            });
            
            // Count how many logs are in each range
            const logCounts = {
                keystroke: Array(mergedTimeRanges.length).fill(0),
                mouse: Array(mergedTimeRanges.length).fill(0)
            };
            
            // Filter logs based on merged time ranges
            ['keystroke', 'mouse'].forEach(logType => {
                if (!session.logs[logType] || session.logs[logType].length === 0) {
                    console.log(`DEBUG: No ${logType} logs to filter`);
                    return;
                }
                
                // Filter logs to only include those in selected time ranges
                session.logs[logType].forEach(log => {
                    const timestamp = log.timestamp;
                    
                    // Check if this log entry falls within any merged time range
                    let isInSelectedRange = false;
                    
                    for (let i = 0; i < mergedTimeRanges.length; i++) {
                        const range = mergedTimeRanges[i];
                        if (timestamp >= range.start && timestamp <= range.end) {
                            isInSelectedRange = true;
                            logCounts[logType][i]++;
                            break;
                        }
                    }
                    
                    if (isInSelectedRange) {
                        filteredLogs[logType].push(log);
                    }
                });
                
                console.log(`DEBUG: Filtered ${logType} logs: ${filteredLogs[logType].length} of ${session.logs[logType].length} kept (${session.logs[logType].length - filteredLogs[logType].length} excluded)`);
            });
            
            // Log counts for each time range
            mergedTimeRanges.forEach((range, idx) => {
                console.log(`DEBUG: Time range ${idx+1} (${range.displayName} - ${range.chunkName}) contains ${logCounts.keystroke[idx]} keystroke logs and ${logCounts.mouse[idx]} mouse logs`);
            });
            
            // If many logs were excluded, log a more detailed breakdown
            if (session.logs.keystroke.length > 0 && filteredLogs.keystroke.length < session.logs.keystroke.length * 0.9) {
                console.log(`DEBUG: ALERT - More than 10% of keystroke logs were excluded. Analyzing excluded logs...`);
                // Count logs that fall outside any time range
                const outsideAnyRangeCount = {
                    keystroke: 0,
                    mouse: 0
                };
                
                ['keystroke', 'mouse'].forEach(logType => {
                    if (!session.logs[logType]) return;
                    
                    session.logs[logType].forEach(log => {
                        const timestamp = log.timestamp;
                        let insideAnyRange = false;
                        
                        for (const range of mergedTimeRanges) {
                            if (timestamp >= range.start && timestamp <= range.end) {
                                insideAnyRange = true;
                                break;
                            }
                        }
                        
                        if (!insideAnyRange) {
                            outsideAnyRangeCount[logType]++;
                        }
                    });
                });
                
                console.log(`DEBUG: Logs outside any selected time range: ${outsideAnyRangeCount.keystroke} keystrokes, ${outsideAnyRangeCount.mouse} mouse events`);
                
                // Find logs in unselected ranges, especially the one chunk we're concerned about
                const unselectedRangeStats = {};
                
                // Find unselected chunks time ranges
                for (const displayKey in session.displays) {
                    const display = session.displays[displayKey];
                    
                    if (!display.chunks) continue;
                    
                    display.chunks.forEach((chunk, chunkIndex) => {
                        if (chunk.selected) return; // Skip selected chunks
                        
                        // Calculate time range for this unselected chunk
                        let chunkStartTime, chunkEndTime;
                        const frameTimestamps = display.frameTimestamps || [];
                        
                        if (frameTimestamps.length > 0) {
                            const framesPerChunk = 1800;
                            const startFrameIndex = chunkIndex * framesPerChunk;
                            const endFrameIndex = Math.min((chunkIndex + 1) * framesPerChunk - 1, frameTimestamps.length - 1);
                            
                            if (startFrameIndex < frameTimestamps.length) {
                                chunkStartTime = frameTimestamps[startFrameIndex];
                                chunkEndTime = frameTimestamps[endFrameIndex];
                            } else {
                                return;
                            }
                        } else {
                            // Estimate based on logs
                            const firstLogTime = session.logs.keystroke.length > 0 ? 
                                session.logs.keystroke[0].timestamp : 
                                (session.logs.mouse.length > 0 ? session.logs.mouse[0].timestamp : 0);
                                
                            const lastLogTime = session.logs.keystroke.length > 0 ? 
                                session.logs.keystroke[session.logs.keystroke.length - 1].timestamp : 
                                (session.logs.mouse.length > 0 ? session.logs.mouse[session.logs.mouse.length - 1].timestamp : 0);
                            
                            if (firstLogTime === 0 || lastLogTime === 0) return;
                            
                            const totalDuration = Math.ceil((lastLogTime - firstLogTime) / 1000);
                            const totalChunks = Math.ceil(totalDuration / 60);
                            
                            const chunkStartPercent = chunkIndex / totalChunks;
                            const chunkEndPercent = (chunkIndex + 1) / totalChunks;
                            
                            chunkStartTime = firstLogTime + (chunkStartPercent * (lastLogTime - firstLogTime));
                            chunkEndTime = firstLogTime + (chunkEndPercent * (lastLogTime - firstLogTime));
                        }
                        
                        if (chunkStartTime !== undefined && chunkEndTime !== undefined) {
                            const rangeKey = `${display.name}_chunk_${chunkIndex}`;
                            unselectedRangeStats[rangeKey] = {
                                start: chunkStartTime,
                                end: chunkEndTime,
                                displayName: display.name,
                                chunkName: chunk.name || `Chunk ${chunkIndex+1}`,
                                keystrokeCount: 0,
                                mouseCount: 0
                            };
                            
                            // Count logs in this unselected range
                            ['keystroke', 'mouse'].forEach(logType => {
                                if (!session.logs[logType]) return;
                                
                                session.logs[logType].forEach(log => {
                                    const timestamp = log.timestamp;
                                    if (timestamp >= chunkStartTime && timestamp <= chunkEndTime) {
                                        unselectedRangeStats[rangeKey][logType + 'Count']++;
                                    }
                                });
                            });
                        }
                    });
                }
                
                // Output unselected ranges stats
                console.log(`DEBUG: Analyzing logs in unselected chunks:`);
                for (const key in unselectedRangeStats) {
                    const stats = unselectedRangeStats[key];
                    console.log(`DEBUG: Unselected ${stats.displayName} - ${stats.chunkName}: ${stats.keystrokeCount} keystrokes, ${stats.mouseCount} mouse events (${new Date(stats.start).toISOString()} - ${new Date(stats.end).toISOString()})`);
                }
            }
            
            return filteredLogs;
        }
        
        /**
         * Handle the upload button click
         */
        function handleUpload() {
            // Show loading
            showLoading();
            
            try {
                // Prepare upload data
                const uploadData = {
                    sessions: []
                };
                
                // Track total vs filtered log counts
                const logStats = {
                    total: { keystroke: 0, mouse: 0 },
                    filtered: { keystroke: 0, mouse: 0 }
                };
                
                // Store excluded time ranges for display
                const excludedTimeRanges = [];
                
                console.log(`DEBUG: Starting upload preparation, processing ${sessions.length} sessions`);
                
                // Process each selected session
                sessions.forEach(session => {
                    // Skip unselected sessions
                    if (!session.selected) {
                        console.log(`DEBUG: Session ${session.name} is unselected, skipping`);
                        return;
                    }
                    
                    console.log(`DEBUG: Processing selected session ${session.name}`);
                    
                    // Count selected displays and chunks for debugging
                    let selectedDisplays = 0;
                    let totalSelectedChunks = 0;
                    
                    for (const displayKey in session.displays) {
                        const display = session.displays[displayKey];
                        if (display.selected) {
                            selectedDisplays++;
                            const selectedChunks = display.chunks ? display.chunks.filter(c => c.selected).length : 0;
                            totalSelectedChunks += selectedChunks;
                        }
                    }
                    
                    console.log(`DEBUG: Session ${session.name} has ${selectedDisplays} selected displays with ${totalSelectedChunks} total selected chunks`);
                    
                    // Count total logs before filtering
                    if (session.logs) {
                        logStats.total.keystroke += session.logs.keystroke?.length || 0;
                        logStats.total.mouse += session.logs.mouse?.length || 0;
                        
                        console.log(`DEBUG: Session ${session.name} has ${session.logs.keystroke?.length || 0} total keystroke logs and ${session.logs.mouse?.length || 0} total mouse logs before filtering`);
                    }
                    
                    // Get all time ranges for all chunks (selected and unselected)
                    // This helps us identify excluded time ranges
                    const allTimeRanges = [];
                    const excludedRanges = [];
                    
                    for (const displayKey in session.displays) {
                        const display = session.displays[displayKey];
                        
                        if (!display.chunks || display.chunks.length === 0) {
                            continue;
                        }
                        
                        // Get frame timestamps if available
                        const frameTimestamps = display.frameTimestamps || [];
                        
                        // For each chunk, calculate its time range
                        display.chunks.forEach((chunk, chunkIndex) => {
                            // Determine time range for this chunk
                            const chunkDuration = 60; // seconds
                            let chunkStartTime, chunkEndTime;
                            
                            if (frameTimestamps.length > 0) {
                                // Calculate start and end frames for this chunk
                                const framesPerChunk = 1800; // 30fps * 60s
                                const startFrameIndex = chunkIndex * framesPerChunk;
                                const endFrameIndex = Math.min((chunkIndex + 1) * framesPerChunk - 1, frameTimestamps.length - 1);
                                
                                // Get timestamps from frames.log if available
                                if (startFrameIndex < frameTimestamps.length) {
                                    chunkStartTime = frameTimestamps[startFrameIndex];
                                    chunkEndTime = frameTimestamps[endFrameIndex];
                                } else {
                                    return;
                                }
                            } else {
                                // No frame timestamps, estimate based on log timestamps
                                const firstLogTime = session.logs?.keystroke?.length > 0 ? 
                                    session.logs.keystroke[0].timestamp : 
                                    (session.logs?.mouse?.length > 0 ? session.logs.mouse[0].timestamp : 0);
                                    
                                const lastLogTime = session.logs?.keystroke?.length > 0 ? 
                                    session.logs.keystroke[session.logs.keystroke.length - 1].timestamp : 
                                    (session.logs?.mouse?.length > 0 ? session.logs.mouse[session.logs.mouse.length - 1].timestamp : 0);
                                
                                if (firstLogTime === 0 || lastLogTime === 0) {
                                    return;
                                }
                                
                                const totalDuration = Math.ceil((lastLogTime - firstLogTime) / 1000); // in seconds
                                const totalChunks = Math.ceil(totalDuration / chunkDuration);
                                
                                // Calculate normalized time range for this chunk
                                const chunkStartPercent = chunkIndex / totalChunks;
                                const chunkEndPercent = (chunkIndex + 1) / totalChunks;
                                
                                chunkStartTime = firstLogTime + (chunkStartPercent * (lastLogTime - firstLogTime));
                                chunkEndTime = firstLogTime + (chunkEndPercent * (lastLogTime - firstLogTime));
                            }
                            
                            // Add this time range
                            if (chunkStartTime !== undefined && chunkEndTime !== undefined) {
                                const timeRange = {
                                    start: chunkStartTime,
                                    end: chunkEndTime,
                                    selected: display.selected && chunk.selected,
                                    displayName: display.name,
                                    chunkName: chunk.name || `Chunk ${chunkIndex+1}`,
                                    chunkIndex: chunkIndex
                                };
                                
                                allTimeRanges.push(timeRange);
                                
                                // If this chunk is not selected, add to excluded ranges
                                if (!display.selected || !chunk.selected) {
                                    excludedRanges.push(timeRange);
                                }
                            }
                        });
                    }
                    
                    // Sort all time ranges by start time
                    allTimeRanges.sort((a, b) => a.start - b.start);
                    excludedRanges.sort((a, b) => a.start - b.start);
                    
                    // Add excluded ranges to our global list with session info
                    if (excludedRanges.length > 0) {
                        excludedTimeRanges.push({
                            sessionName: session.name,
                            ranges: excludedRanges
                        });
                    }
                    
                    // Filter logs for this session based on selected chunks
                    const filteredLogs = filterLogsByChunks(session);
                    
                    // Count filtered logs
                    logStats.filtered.keystroke += filteredLogs.keystroke.length;
                    logStats.filtered.mouse += filteredLogs.mouse.length;
                    
                    // Prepare display data
                    const displayData = {};
                    for (const displayKey in session.displays) {
                        const display = session.displays[displayKey];
                        
                        // Skip unselected displays
                        if (!display.selected) {
                            continue;
                        }
                        
                        // Get selected chunks
                        const selectedChunks = display.chunks.filter(chunk => chunk.selected);
                        
                        if (selectedChunks.length > 0) {
                            displayData[displayKey] = {
                                name: display.name,
                                chunks: selectedChunks.map(chunk => {
                                    // Just get the name for the demo
                                    return chunk.name || (chunk.webkitRelativePath ? chunk.webkitRelativePath.split('/').pop() : 'chunk');
                                })
                            };
                        }
                    }
                    
                    // Add to upload data if there's at least one display with chunks
                    if (Object.keys(displayData).length > 0) {
                        uploadData.sessions.push({
                            name: session.name,
                            displays: displayData,
                            logs: filteredLogs
                        });
                    }
                });
                
                // Hide loading
                hideLoading();
                
                // Show upload data (for demonstration)
                if (uploadData.sessions.length === 0) {
                    showMessage('No data selected for upload', 'error');
                    return;
                }
                
                // Calculate filter percentages
                const keystrokeFilterPercent = Math.round((logStats.total.keystroke - logStats.filtered.keystroke) / Math.max(1, logStats.total.keystroke) * 100);
                const mouseFilterPercent = Math.round((logStats.total.mouse - logStats.filtered.mouse) / Math.max(1, logStats.total.mouse) * 100);
                
                // Format excluded time ranges for display
                let excludedRangesHTML = '';
                if (excludedTimeRanges.length > 0) {
                    excludedRangesHTML = '<h4>Excluded Time Ranges:</h4><div style="max-height: 200px; overflow-y: auto; border: 1px solid #dee2e6; padding: 10px; margin-bottom: 15px; font-size: 13px;">';
                    
                    excludedTimeRanges.forEach(sessionRanges => {
                        excludedRangesHTML += `<p><strong>Session: ${sessionRanges.sessionName}</strong></p><ul>`;
                        
                        sessionRanges.ranges.forEach(range => {
                            // Format timestamps
                            const startTime = new Date(range.start).toISOString().substring(11, 23); // Get HH:MM:SS.sss
                            const endTime = new Date(range.end).toISOString().substring(11, 23);
                            const duration = ((range.end - range.start) / 1000).toFixed(2);
                            
                            excludedRangesHTML += `<li>${range.displayName} - ${range.chunkName}: ${startTime} to ${endTime} (${duration}s)</li>`;
                        });
                        
                        excludedRangesHTML += '</ul>';
                    });
                    
                    excludedRangesHTML += '</div>';
                }
                
                // Create a modal to show the data that would be uploaded
                const modal = document.createElement('div');
                modal.style.position = 'fixed';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.backgroundColor = 'rgba(0,0,0,0.7)';
                modal.style.zIndex = '1000';
                modal.style.display = 'flex';
                modal.style.justifyContent = 'center';
                modal.style.alignItems = 'center';
                
                const modalContent = document.createElement('div');
                modalContent.style.backgroundColor = 'white';
                modalContent.style.padding = '20px';
                modalContent.style.borderRadius = '10px';
                modalContent.style.maxWidth = '80%';
                modalContent.style.maxHeight = '80%';
                modalContent.style.overflow = 'auto';
                
                modalContent.innerHTML = `
                    <h3>Upload Data Preview</h3>
                    <p>The following data would be uploaded:</p>
                    <ul>
                        <li><strong>Sessions:</strong> ${uploadData.sessions.length}</li>
                        <li><strong>Total Displays:</strong> ${uploadData.sessions.reduce((sum, s) => sum + Object.keys(s.displays).length, 0)}</li>
                        <li><strong>Total Chunks:</strong> ${uploadData.sessions.reduce((sum, s) => {
                            return sum + Object.values(s.displays).reduce((sum2, d) => sum2 + d.chunks.length, 0);
                        }, 0)}</li>
                    </ul>
                    
                    <h4>Filtered Log Statistics:</h4>
                    <table style="width: 100%; border-collapse: collapse; margin-bottom: 15px;">
                        <tr style="background-color: #f8f9fa; font-weight: bold;">
                            <td style="padding: 8px; border: 1px solid #dee2e6;">Log Type</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">Total Entries</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">Included Entries</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">Excluded Entries</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">Excluded %</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">Keystrokes</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${logStats.total.keystroke}</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${logStats.filtered.keystroke}</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${logStats.total.keystroke - logStats.filtered.keystroke}</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${keystrokeFilterPercent}%</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">Mouse Events</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${logStats.total.mouse}</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${logStats.filtered.mouse}</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${logStats.total.mouse - logStats.filtered.mouse}</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${mouseFilterPercent}%</td>
                        </tr>
                    </table>
                    
                    ${excludedRangesHTML}
                    
                    <p><strong>Note:</strong> This is a dummy upload. In a real implementation, files would be sent to a server.</p>
                    <div style="margin-top: 20px; text-align: center;">
                        <button id="closeModalBtn" style="padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>
                    </div>
                `;
                
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                // Add close button event
                document.getElementById('closeModalBtn').addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
                
                // Also show a message
                showMessage('Upload preview generated. This is a dummy implementation.', 'notice');
                
            } catch (error) {
                hideLoading();
                console.error('Error during upload:', error);
                showMessage('Error preparing upload: ' + error.message, 'error');
            }
        }
    </script>
</body>
</html>